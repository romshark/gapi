package compiler

// Code generated by peg parser.peg DO NOT EDIT

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleSchema
	ruleDclSc
	ruleDclAl
	ruleDclEn
	ruleDclSt
	ruleDclRv
	ruleDclTr
	ruleDclUn
	ruleDclQr
	ruleDclMt
	ruleDclSb
	ruleBlkEn
	ruleBlkSt
	ruleBlkRv
	ruleBlkUn
	ruleStFld
	ruleRvPrp
	ruleArgs
	ruleTp
	ruleWrd
	ruleSpLn
	ruleSpOpt
	ruleSpLnOpt
	ruleSpVr
	ruleOEQ
	ruleONU
	ruleOLI
	ruleKSC
	ruleKAL
	ruleKEN
	ruleKST
	ruleKRV
	ruleKTR
	ruleKUN
	ruleKQR
	ruleKMT
	ruleKSB
	rulePRN
	rulePRNE
	ruleBLK
	ruleBLKE
)

var rul3s = [...]string{
	"Unknown",
	"Schema",
	"DclSc",
	"DclAl",
	"DclEn",
	"DclSt",
	"DclRv",
	"DclTr",
	"DclUn",
	"DclQr",
	"DclMt",
	"DclSb",
	"BlkEn",
	"BlkSt",
	"BlkRv",
	"BlkUn",
	"StFld",
	"RvPrp",
	"Args",
	"Tp",
	"Wrd",
	"SpLn",
	"SpOpt",
	"SpLnOpt",
	"SpVr",
	"OEQ",
	"ONU",
	"OLI",
	"KSC",
	"KAL",
	"KEN",
	"KST",
	"KRV",
	"KTR",
	"KUN",
	"KQR",
	"KMT",
	"KSB",
	"PRN",
	"PRNE",
	"BLK",
	"BLKE",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type GAPIParser struct {
	Buffer string
	buffer []rune
	rules  [42]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *GAPIParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *GAPIParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *GAPIParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *GAPIParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *GAPIParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func Pretty(pretty bool) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *GAPIParser) Init(options ...func(*GAPIParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Schema <- <(SpOpt DclSc (SpOpt (DclAl / DclEn / DclSt / DclTr / DclRv / DclUn / DclQr / DclMt / DclSb))* SpOpt)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				if !_rules[ruleDclSc]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l3
					}
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleDclAl]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclEn]() {
							goto l6
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclSt]() {
							goto l7
						}
						goto l4
					l7:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclTr]() {
							goto l8
						}
						goto l4
					l8:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclRv]() {
							goto l9
						}
						goto l4
					l9:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclUn]() {
							goto l10
						}
						goto l4
					l10:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclQr]() {
							goto l11
						}
						goto l4
					l11:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclMt]() {
							goto l12
						}
						goto l4
					l12:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclSb]() {
							goto l3
						}
					}
				l4:
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				add(ruleSchema, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DclSc <- <(KSC SpLn Wrd)> */
		func() bool {
			position13, tokenIndex13 := position, tokenIndex
			{
				position14 := position
				if !_rules[ruleKSC]() {
					goto l13
				}
				if !_rules[ruleSpLn]() {
					goto l13
				}
				if !_rules[ruleWrd]() {
					goto l13
				}
				add(ruleDclSc, position14)
			}
			return true
		l13:
			position, tokenIndex = position13, tokenIndex13
			return false
		},
		/* 2 DclAl <- <(KAL SpLn Wrd SpLn OEQ SpLn Wrd)> */
		func() bool {
			position15, tokenIndex15 := position, tokenIndex
			{
				position16 := position
				if !_rules[ruleKAL]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleWrd]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleOEQ]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleWrd]() {
					goto l15
				}
				add(ruleDclAl, position16)
			}
			return true
		l15:
			position, tokenIndex = position15, tokenIndex15
			return false
		},
		/* 3 DclEn <- <(KEN SpLn Wrd SpLnOpt BlkEn)> */
		func() bool {
			position17, tokenIndex17 := position, tokenIndex
			{
				position18 := position
				if !_rules[ruleKEN]() {
					goto l17
				}
				if !_rules[ruleSpLn]() {
					goto l17
				}
				if !_rules[ruleWrd]() {
					goto l17
				}
				if !_rules[ruleSpLnOpt]() {
					goto l17
				}
				if !_rules[ruleBlkEn]() {
					goto l17
				}
				add(ruleDclEn, position18)
			}
			return true
		l17:
			position, tokenIndex = position17, tokenIndex17
			return false
		},
		/* 4 DclSt <- <(KST SpLn Wrd SpLnOpt BlkSt)> */
		func() bool {
			position19, tokenIndex19 := position, tokenIndex
			{
				position20 := position
				if !_rules[ruleKST]() {
					goto l19
				}
				if !_rules[ruleSpLn]() {
					goto l19
				}
				if !_rules[ruleWrd]() {
					goto l19
				}
				if !_rules[ruleSpLnOpt]() {
					goto l19
				}
				if !_rules[ruleBlkSt]() {
					goto l19
				}
				add(ruleDclSt, position20)
			}
			return true
		l19:
			position, tokenIndex = position19, tokenIndex19
			return false
		},
		/* 5 DclRv <- <(KRV SpLn Wrd SpLnOpt BlkRv)> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if !_rules[ruleKRV]() {
					goto l21
				}
				if !_rules[ruleSpLn]() {
					goto l21
				}
				if !_rules[ruleWrd]() {
					goto l21
				}
				if !_rules[ruleSpLnOpt]() {
					goto l21
				}
				if !_rules[ruleBlkRv]() {
					goto l21
				}
				add(ruleDclRv, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 6 DclTr <- <(KTR SpLn Wrd SpLnOpt BlkRv)> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if !_rules[ruleKTR]() {
					goto l23
				}
				if !_rules[ruleSpLn]() {
					goto l23
				}
				if !_rules[ruleWrd]() {
					goto l23
				}
				if !_rules[ruleSpLnOpt]() {
					goto l23
				}
				if !_rules[ruleBlkRv]() {
					goto l23
				}
				add(ruleDclTr, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 7 DclUn <- <(KUN SpLn Wrd SpLnOpt BlkUn)> */
		func() bool {
			position25, tokenIndex25 := position, tokenIndex
			{
				position26 := position
				if !_rules[ruleKUN]() {
					goto l25
				}
				if !_rules[ruleSpLn]() {
					goto l25
				}
				if !_rules[ruleWrd]() {
					goto l25
				}
				if !_rules[ruleSpLnOpt]() {
					goto l25
				}
				if !_rules[ruleBlkUn]() {
					goto l25
				}
				add(ruleDclUn, position26)
			}
			return true
		l25:
			position, tokenIndex = position25, tokenIndex25
			return false
		},
		/* 8 DclQr <- <(KQR SpLn Wrd SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[ruleKQR]() {
					goto l27
				}
				if !_rules[ruleSpLn]() {
					goto l27
				}
				if !_rules[ruleWrd]() {
					goto l27
				}
				if !_rules[ruleSpLnOpt]() {
					goto l27
				}
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l29
					}
					goto l30
				l29:
					position, tokenIndex = position29, tokenIndex29
				}
			l30:
				if !_rules[ruleSpLnOpt]() {
					goto l27
				}
				if !_rules[ruleTp]() {
					goto l27
				}
				add(ruleDclQr, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 9 DclMt <- <(KMT SpLn Wrd SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				if !_rules[ruleKMT]() {
					goto l31
				}
				if !_rules[ruleSpLn]() {
					goto l31
				}
				if !_rules[ruleWrd]() {
					goto l31
				}
				if !_rules[ruleSpLnOpt]() {
					goto l31
				}
				{
					position33, tokenIndex33 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l33
					}
					goto l34
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
			l34:
				if !_rules[ruleSpLnOpt]() {
					goto l31
				}
				if !_rules[ruleTp]() {
					goto l31
				}
				add(ruleDclMt, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 10 DclSb <- <(KSB SpLn Wrd SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleKSB]() {
					goto l35
				}
				if !_rules[ruleSpLn]() {
					goto l35
				}
				if !_rules[ruleWrd]() {
					goto l35
				}
				if !_rules[ruleSpLnOpt]() {
					goto l35
				}
				{
					position37, tokenIndex37 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l37
					}
					goto l38
				l37:
					position, tokenIndex = position37, tokenIndex37
				}
			l38:
				if !_rules[ruleSpLnOpt]() {
					goto l35
				}
				if !_rules[ruleTp]() {
					goto l35
				}
				add(ruleDclSb, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 11 BlkEn <- <(BLK (SpOpt Wrd)* SpOpt BLKE)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[ruleBLK]() {
					goto l39
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l42
					}
					if !_rules[ruleWrd]() {
						goto l42
					}
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				if !_rules[ruleSpOpt]() {
					goto l39
				}
				if !_rules[ruleBLKE]() {
					goto l39
				}
				add(ruleBlkEn, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 12 BlkSt <- <(BLK (SpOpt StFld)* SpOpt BLKE)> */
		func() bool {
			position43, tokenIndex43 := position, tokenIndex
			{
				position44 := position
				if !_rules[ruleBLK]() {
					goto l43
				}
			l45:
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l46
					}
					if !_rules[ruleStFld]() {
						goto l46
					}
					goto l45
				l46:
					position, tokenIndex = position46, tokenIndex46
				}
				if !_rules[ruleSpOpt]() {
					goto l43
				}
				if !_rules[ruleBLKE]() {
					goto l43
				}
				add(ruleBlkSt, position44)
			}
			return true
		l43:
			position, tokenIndex = position43, tokenIndex43
			return false
		},
		/* 13 BlkRv <- <(BLK SpOpt RvPrp+ SpOpt BLKE)> */
		func() bool {
			position47, tokenIndex47 := position, tokenIndex
			{
				position48 := position
				if !_rules[ruleBLK]() {
					goto l47
				}
				if !_rules[ruleSpOpt]() {
					goto l47
				}
				if !_rules[ruleRvPrp]() {
					goto l47
				}
			l49:
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleRvPrp]() {
						goto l50
					}
					goto l49
				l50:
					position, tokenIndex = position50, tokenIndex50
				}
				if !_rules[ruleSpOpt]() {
					goto l47
				}
				if !_rules[ruleBLKE]() {
					goto l47
				}
				add(ruleBlkRv, position48)
			}
			return true
		l47:
			position, tokenIndex = position47, tokenIndex47
			return false
		},
		/* 14 BlkUn <- <(BLK (SpOpt Wrd)+ SpOpt BLKE)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if !_rules[ruleBLK]() {
					goto l51
				}
				if !_rules[ruleSpOpt]() {
					goto l51
				}
				if !_rules[ruleWrd]() {
					goto l51
				}
			l53:
				{
					position54, tokenIndex54 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l54
					}
					if !_rules[ruleWrd]() {
						goto l54
					}
					goto l53
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
				if !_rules[ruleSpOpt]() {
					goto l51
				}
				if !_rules[ruleBLKE]() {
					goto l51
				}
				add(ruleBlkUn, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 15 StFld <- <(Wrd SpLn Tp)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleWrd]() {
					goto l55
				}
				if !_rules[ruleSpLn]() {
					goto l55
				}
				if !_rules[ruleTp]() {
					goto l55
				}
				add(ruleStFld, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 16 RvPrp <- <(Wrd SpLn Args? Tp)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if !_rules[ruleWrd]() {
					goto l57
				}
				if !_rules[ruleSpLn]() {
					goto l57
				}
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l59
					}
					goto l60
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
			l60:
				if !_rules[ruleTp]() {
					goto l57
				}
				add(ruleRvPrp, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 17 Args <- <(PRN SpOpt (Wrd Tp ',')+ SpOpt PRNE)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[rulePRN]() {
					goto l61
				}
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				if !_rules[ruleWrd]() {
					goto l61
				}
				if !_rules[ruleTp]() {
					goto l61
				}
				if buffer[position] != rune(',') {
					goto l61
				}
				position++
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleWrd]() {
						goto l64
					}
					if !_rules[ruleTp]() {
						goto l64
					}
					if buffer[position] != rune(',') {
						goto l64
					}
					position++
					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				if !_rules[rulePRNE]() {
					goto l61
				}
				add(ruleArgs, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 18 Tp <- <(((ONU OLI) / ONU / OLI)* Wrd)> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
			l67:
				{
					position68, tokenIndex68 := position, tokenIndex
					{
						position69, tokenIndex69 := position, tokenIndex
						if !_rules[ruleONU]() {
							goto l70
						}
						if !_rules[ruleOLI]() {
							goto l70
						}
						goto l69
					l70:
						position, tokenIndex = position69, tokenIndex69
						if !_rules[ruleONU]() {
							goto l71
						}
						goto l69
					l71:
						position, tokenIndex = position69, tokenIndex69
						if !_rules[ruleOLI]() {
							goto l68
						}
					}
				l69:
					goto l67
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
				if !_rules[ruleWrd]() {
					goto l65
				}
				add(ruleTp, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 19 Wrd <- <([a-z] / [A-Z] / [0-9] / '_')+> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				{
					position76, tokenIndex76 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l77
					}
					position++
					goto l76
				l77:
					position, tokenIndex = position76, tokenIndex76
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l78
					}
					position++
					goto l76
				l78:
					position, tokenIndex = position76, tokenIndex76
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l79
					}
					position++
					goto l76
				l79:
					position, tokenIndex = position76, tokenIndex76
					if buffer[position] != rune('_') {
						goto l72
					}
					position++
				}
			l76:
			l74:
				{
					position75, tokenIndex75 := position, tokenIndex
					{
						position80, tokenIndex80 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l81
						}
						position++
						goto l80
					l81:
						position, tokenIndex = position80, tokenIndex80
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l82
						}
						position++
						goto l80
					l82:
						position, tokenIndex = position80, tokenIndex80
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l83
						}
						position++
						goto l80
					l83:
						position, tokenIndex = position80, tokenIndex80
						if buffer[position] != rune('_') {
							goto l75
						}
						position++
					}
				l80:
					goto l74
				l75:
					position, tokenIndex = position75, tokenIndex75
				}
				add(ruleWrd, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 20 SpLn <- <(' ' / '\t')+> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				{
					position88, tokenIndex88 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l89
					}
					position++
					goto l88
				l89:
					position, tokenIndex = position88, tokenIndex88
					if buffer[position] != rune('\t') {
						goto l84
					}
					position++
				}
			l88:
			l86:
				{
					position87, tokenIndex87 := position, tokenIndex
					{
						position90, tokenIndex90 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l91
						}
						position++
						goto l90
					l91:
						position, tokenIndex = position90, tokenIndex90
						if buffer[position] != rune('\t') {
							goto l87
						}
						position++
					}
				l90:
					goto l86
				l87:
					position, tokenIndex = position87, tokenIndex87
				}
				add(ruleSpLn, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 21 SpOpt <- <(SpLn / SpVr)*> */
		func() bool {
			{
				position93 := position
			l94:
				{
					position95, tokenIndex95 := position, tokenIndex
					{
						position96, tokenIndex96 := position, tokenIndex
						if !_rules[ruleSpLn]() {
							goto l97
						}
						goto l96
					l97:
						position, tokenIndex = position96, tokenIndex96
						if !_rules[ruleSpVr]() {
							goto l95
						}
					}
				l96:
					goto l94
				l95:
					position, tokenIndex = position95, tokenIndex95
				}
				add(ruleSpOpt, position93)
			}
			return true
		},
		/* 22 SpLnOpt <- <(' ' / '\t')*> */
		func() bool {
			{
				position99 := position
			l100:
				{
					position101, tokenIndex101 := position, tokenIndex
					{
						position102, tokenIndex102 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l103
						}
						position++
						goto l102
					l103:
						position, tokenIndex = position102, tokenIndex102
						if buffer[position] != rune('\t') {
							goto l101
						}
						position++
					}
				l102:
					goto l100
				l101:
					position, tokenIndex = position101, tokenIndex101
				}
				add(ruleSpLnOpt, position99)
			}
			return true
		},
		/* 23 SpVr <- <('\n' / ('\r' '\n'))+> */
		func() bool {
			position104, tokenIndex104 := position, tokenIndex
			{
				position105 := position
				{
					position108, tokenIndex108 := position, tokenIndex
					if buffer[position] != rune('\n') {
						goto l109
					}
					position++
					goto l108
				l109:
					position, tokenIndex = position108, tokenIndex108
					if buffer[position] != rune('\r') {
						goto l104
					}
					position++
					if buffer[position] != rune('\n') {
						goto l104
					}
					position++
				}
			l108:
			l106:
				{
					position107, tokenIndex107 := position, tokenIndex
					{
						position110, tokenIndex110 := position, tokenIndex
						if buffer[position] != rune('\n') {
							goto l111
						}
						position++
						goto l110
					l111:
						position, tokenIndex = position110, tokenIndex110
						if buffer[position] != rune('\r') {
							goto l107
						}
						position++
						if buffer[position] != rune('\n') {
							goto l107
						}
						position++
					}
				l110:
					goto l106
				l107:
					position, tokenIndex = position107, tokenIndex107
				}
				add(ruleSpVr, position105)
			}
			return true
		l104:
			position, tokenIndex = position104, tokenIndex104
			return false
		},
		/* 24 OEQ <- <'='> */
		func() bool {
			position112, tokenIndex112 := position, tokenIndex
			{
				position113 := position
				if buffer[position] != rune('=') {
					goto l112
				}
				position++
				add(ruleOEQ, position113)
			}
			return true
		l112:
			position, tokenIndex = position112, tokenIndex112
			return false
		},
		/* 25 ONU <- <'?'> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				if buffer[position] != rune('?') {
					goto l114
				}
				position++
				add(ruleONU, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 26 OLI <- <('[' ']')> */
		func() bool {
			position116, tokenIndex116 := position, tokenIndex
			{
				position117 := position
				if buffer[position] != rune('[') {
					goto l116
				}
				position++
				if buffer[position] != rune(']') {
					goto l116
				}
				position++
				add(ruleOLI, position117)
			}
			return true
		l116:
			position, tokenIndex = position116, tokenIndex116
			return false
		},
		/* 27 KSC <- <('s' 'c' 'h' 'e' 'm' 'a')> */
		func() bool {
			position118, tokenIndex118 := position, tokenIndex
			{
				position119 := position
				if buffer[position] != rune('s') {
					goto l118
				}
				position++
				if buffer[position] != rune('c') {
					goto l118
				}
				position++
				if buffer[position] != rune('h') {
					goto l118
				}
				position++
				if buffer[position] != rune('e') {
					goto l118
				}
				position++
				if buffer[position] != rune('m') {
					goto l118
				}
				position++
				if buffer[position] != rune('a') {
					goto l118
				}
				position++
				add(ruleKSC, position119)
			}
			return true
		l118:
			position, tokenIndex = position118, tokenIndex118
			return false
		},
		/* 28 KAL <- <('a' 'l' 'i' 'a' 's')> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				if buffer[position] != rune('a') {
					goto l120
				}
				position++
				if buffer[position] != rune('l') {
					goto l120
				}
				position++
				if buffer[position] != rune('i') {
					goto l120
				}
				position++
				if buffer[position] != rune('a') {
					goto l120
				}
				position++
				if buffer[position] != rune('s') {
					goto l120
				}
				position++
				add(ruleKAL, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 29 KEN <- <('e' 'n' 'u' 'm')> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('e') {
					goto l122
				}
				position++
				if buffer[position] != rune('n') {
					goto l122
				}
				position++
				if buffer[position] != rune('u') {
					goto l122
				}
				position++
				if buffer[position] != rune('m') {
					goto l122
				}
				position++
				add(ruleKEN, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 30 KST <- <('s' 't' 'r' 'u' 'c' 't')> */
		func() bool {
			position124, tokenIndex124 := position, tokenIndex
			{
				position125 := position
				if buffer[position] != rune('s') {
					goto l124
				}
				position++
				if buffer[position] != rune('t') {
					goto l124
				}
				position++
				if buffer[position] != rune('r') {
					goto l124
				}
				position++
				if buffer[position] != rune('u') {
					goto l124
				}
				position++
				if buffer[position] != rune('c') {
					goto l124
				}
				position++
				if buffer[position] != rune('t') {
					goto l124
				}
				position++
				add(ruleKST, position125)
			}
			return true
		l124:
			position, tokenIndex = position124, tokenIndex124
			return false
		},
		/* 31 KRV <- <('r' 'e' 's' 'o' 'l' 'v' 'e' 'r')> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune('r') {
					goto l126
				}
				position++
				if buffer[position] != rune('e') {
					goto l126
				}
				position++
				if buffer[position] != rune('s') {
					goto l126
				}
				position++
				if buffer[position] != rune('o') {
					goto l126
				}
				position++
				if buffer[position] != rune('l') {
					goto l126
				}
				position++
				if buffer[position] != rune('v') {
					goto l126
				}
				position++
				if buffer[position] != rune('e') {
					goto l126
				}
				position++
				if buffer[position] != rune('r') {
					goto l126
				}
				position++
				add(ruleKRV, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 32 KTR <- <('t' 'r' 'a' 'i' 't')> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if buffer[position] != rune('t') {
					goto l128
				}
				position++
				if buffer[position] != rune('r') {
					goto l128
				}
				position++
				if buffer[position] != rune('a') {
					goto l128
				}
				position++
				if buffer[position] != rune('i') {
					goto l128
				}
				position++
				if buffer[position] != rune('t') {
					goto l128
				}
				position++
				add(ruleKTR, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 33 KUN <- <('u' 'n' 'i' 'o' 'n')> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if buffer[position] != rune('u') {
					goto l130
				}
				position++
				if buffer[position] != rune('n') {
					goto l130
				}
				position++
				if buffer[position] != rune('i') {
					goto l130
				}
				position++
				if buffer[position] != rune('o') {
					goto l130
				}
				position++
				if buffer[position] != rune('n') {
					goto l130
				}
				position++
				add(ruleKUN, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 34 KQR <- <('q' 'u' 'e' 'r' 'y')> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				if buffer[position] != rune('q') {
					goto l132
				}
				position++
				if buffer[position] != rune('u') {
					goto l132
				}
				position++
				if buffer[position] != rune('e') {
					goto l132
				}
				position++
				if buffer[position] != rune('r') {
					goto l132
				}
				position++
				if buffer[position] != rune('y') {
					goto l132
				}
				position++
				add(ruleKQR, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 35 KMT <- <('m' 'u' 't' 'a' 't' 'i' 'o' 'n')> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if buffer[position] != rune('m') {
					goto l134
				}
				position++
				if buffer[position] != rune('u') {
					goto l134
				}
				position++
				if buffer[position] != rune('t') {
					goto l134
				}
				position++
				if buffer[position] != rune('a') {
					goto l134
				}
				position++
				if buffer[position] != rune('t') {
					goto l134
				}
				position++
				if buffer[position] != rune('i') {
					goto l134
				}
				position++
				if buffer[position] != rune('o') {
					goto l134
				}
				position++
				if buffer[position] != rune('n') {
					goto l134
				}
				position++
				add(ruleKMT, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 36 KSB <- <('s' 'u' 'b' 's' 'c' 'r' 'i' 'p' 't' 'i' 'o' 'n')> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if buffer[position] != rune('s') {
					goto l136
				}
				position++
				if buffer[position] != rune('u') {
					goto l136
				}
				position++
				if buffer[position] != rune('b') {
					goto l136
				}
				position++
				if buffer[position] != rune('s') {
					goto l136
				}
				position++
				if buffer[position] != rune('c') {
					goto l136
				}
				position++
				if buffer[position] != rune('r') {
					goto l136
				}
				position++
				if buffer[position] != rune('i') {
					goto l136
				}
				position++
				if buffer[position] != rune('p') {
					goto l136
				}
				position++
				if buffer[position] != rune('t') {
					goto l136
				}
				position++
				if buffer[position] != rune('i') {
					goto l136
				}
				position++
				if buffer[position] != rune('o') {
					goto l136
				}
				position++
				if buffer[position] != rune('n') {
					goto l136
				}
				position++
				add(ruleKSB, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 37 PRN <- <'('> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if buffer[position] != rune('(') {
					goto l138
				}
				position++
				add(rulePRN, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 38 PRNE <- <')'> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != rune(')') {
					goto l140
				}
				position++
				add(rulePRNE, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 39 BLK <- <'{'> */
		func() bool {
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				if buffer[position] != rune('{') {
					goto l142
				}
				position++
				add(ruleBLK, position143)
			}
			return true
		l142:
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 40 BLKE <- <'}'> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if buffer[position] != rune('}') {
					goto l144
				}
				position++
				add(ruleBLKE, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
	}
	p.rules = _rules
	return nil
}
