package compiler

// Code generated by R:\go-workspace\bin\peg.exe parser.peg DO NOT EDIT

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleSchema
	ruleDclSc
	ruleDclAl
	ruleDclEn
	ruleDclSt
	ruleDclRv
	ruleDclTr
	ruleDclUn
	ruleDclQr
	ruleDclMt
	ruleDclSb
	ruleBlkEn
	ruleBlkSt
	ruleBlkRv
	ruleBlkUn
	ruleStFld
	ruleRvPrp
	rulePrms
	rulePrmsBd
	rulePrm
	ruleTp
	ruleWrd
	ruleSpLn
	ruleSpOpt
	ruleSpLnOpt
	ruleSpVr
	ruleOEQ
	ruleONU
	ruleOLI
	ruleOCM
	ruleKSC
	ruleKAL
	ruleKEN
	ruleKST
	ruleKRV
	ruleKTR
	ruleKUN
	ruleKQR
	ruleKMT
	ruleKSB
	rulePRN
	rulePRNE
	ruleBLK
	ruleBLKE
)

var rul3s = [...]string{
	"Unknown",
	"Schema",
	"DclSc",
	"DclAl",
	"DclEn",
	"DclSt",
	"DclRv",
	"DclTr",
	"DclUn",
	"DclQr",
	"DclMt",
	"DclSb",
	"BlkEn",
	"BlkSt",
	"BlkRv",
	"BlkUn",
	"StFld",
	"RvPrp",
	"Prms",
	"PrmsBd",
	"Prm",
	"Tp",
	"Wrd",
	"SpLn",
	"SpOpt",
	"SpLnOpt",
	"SpVr",
	"OEQ",
	"ONU",
	"OLI",
	"OCM",
	"KSC",
	"KAL",
	"KEN",
	"KST",
	"KRV",
	"KTR",
	"KUN",
	"KQR",
	"KMT",
	"KSB",
	"PRN",
	"PRNE",
	"BLK",
	"BLKE",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type GAPIParser struct {
	Buffer string
	buffer []rune
	rules  [45]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *GAPIParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *GAPIParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *GAPIParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *GAPIParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *GAPIParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func Pretty(pretty bool) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *GAPIParser) Init(options ...func(*GAPIParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Schema <- <(SpOpt DclSc (SpOpt (DclAl / DclEn / DclSt / DclTr / DclRv / DclUn / DclQr / DclMt / DclSb))* SpOpt)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				if !_rules[ruleDclSc]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l3
					}
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleDclAl]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclEn]() {
							goto l6
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclSt]() {
							goto l7
						}
						goto l4
					l7:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclTr]() {
							goto l8
						}
						goto l4
					l8:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclRv]() {
							goto l9
						}
						goto l4
					l9:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclUn]() {
							goto l10
						}
						goto l4
					l10:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclQr]() {
							goto l11
						}
						goto l4
					l11:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclMt]() {
							goto l12
						}
						goto l4
					l12:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleDclSb]() {
							goto l3
						}
					}
				l4:
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				add(ruleSchema, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DclSc <- <(KSC SpLn Wrd)> */
		func() bool {
			position13, tokenIndex13 := position, tokenIndex
			{
				position14 := position
				if !_rules[ruleKSC]() {
					goto l13
				}
				if !_rules[ruleSpLn]() {
					goto l13
				}
				if !_rules[ruleWrd]() {
					goto l13
				}
				add(ruleDclSc, position14)
			}
			return true
		l13:
			position, tokenIndex = position13, tokenIndex13
			return false
		},
		/* 2 DclAl <- <(KAL SpLn Wrd SpLn OEQ SpLn Wrd)> */
		func() bool {
			position15, tokenIndex15 := position, tokenIndex
			{
				position16 := position
				if !_rules[ruleKAL]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleWrd]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleOEQ]() {
					goto l15
				}
				if !_rules[ruleSpLn]() {
					goto l15
				}
				if !_rules[ruleWrd]() {
					goto l15
				}
				add(ruleDclAl, position16)
			}
			return true
		l15:
			position, tokenIndex = position15, tokenIndex15
			return false
		},
		/* 3 DclEn <- <(KEN SpLn Wrd SpLnOpt BlkEn)> */
		func() bool {
			position17, tokenIndex17 := position, tokenIndex
			{
				position18 := position
				if !_rules[ruleKEN]() {
					goto l17
				}
				if !_rules[ruleSpLn]() {
					goto l17
				}
				if !_rules[ruleWrd]() {
					goto l17
				}
				if !_rules[ruleSpLnOpt]() {
					goto l17
				}
				if !_rules[ruleBlkEn]() {
					goto l17
				}
				add(ruleDclEn, position18)
			}
			return true
		l17:
			position, tokenIndex = position17, tokenIndex17
			return false
		},
		/* 4 DclSt <- <(KST SpLn Wrd SpLnOpt BlkSt)> */
		func() bool {
			position19, tokenIndex19 := position, tokenIndex
			{
				position20 := position
				if !_rules[ruleKST]() {
					goto l19
				}
				if !_rules[ruleSpLn]() {
					goto l19
				}
				if !_rules[ruleWrd]() {
					goto l19
				}
				if !_rules[ruleSpLnOpt]() {
					goto l19
				}
				if !_rules[ruleBlkSt]() {
					goto l19
				}
				add(ruleDclSt, position20)
			}
			return true
		l19:
			position, tokenIndex = position19, tokenIndex19
			return false
		},
		/* 5 DclRv <- <(KRV SpLn Wrd SpLnOpt BlkRv)> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if !_rules[ruleKRV]() {
					goto l21
				}
				if !_rules[ruleSpLn]() {
					goto l21
				}
				if !_rules[ruleWrd]() {
					goto l21
				}
				if !_rules[ruleSpLnOpt]() {
					goto l21
				}
				if !_rules[ruleBlkRv]() {
					goto l21
				}
				add(ruleDclRv, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 6 DclTr <- <(KTR SpLn Wrd SpLnOpt BlkRv)> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if !_rules[ruleKTR]() {
					goto l23
				}
				if !_rules[ruleSpLn]() {
					goto l23
				}
				if !_rules[ruleWrd]() {
					goto l23
				}
				if !_rules[ruleSpLnOpt]() {
					goto l23
				}
				if !_rules[ruleBlkRv]() {
					goto l23
				}
				add(ruleDclTr, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 7 DclUn <- <(KUN SpLn Wrd SpLnOpt BlkUn)> */
		func() bool {
			position25, tokenIndex25 := position, tokenIndex
			{
				position26 := position
				if !_rules[ruleKUN]() {
					goto l25
				}
				if !_rules[ruleSpLn]() {
					goto l25
				}
				if !_rules[ruleWrd]() {
					goto l25
				}
				if !_rules[ruleSpLnOpt]() {
					goto l25
				}
				if !_rules[ruleBlkUn]() {
					goto l25
				}
				add(ruleDclUn, position26)
			}
			return true
		l25:
			position, tokenIndex = position25, tokenIndex25
			return false
		},
		/* 8 DclQr <- <(KQR SpLn Wrd SpLnOpt Prms? SpLnOpt Tp)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[ruleKQR]() {
					goto l27
				}
				if !_rules[ruleSpLn]() {
					goto l27
				}
				if !_rules[ruleWrd]() {
					goto l27
				}
				if !_rules[ruleSpLnOpt]() {
					goto l27
				}
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[rulePrms]() {
						goto l29
					}
					goto l30
				l29:
					position, tokenIndex = position29, tokenIndex29
				}
			l30:
				if !_rules[ruleSpLnOpt]() {
					goto l27
				}
				if !_rules[ruleTp]() {
					goto l27
				}
				add(ruleDclQr, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 9 DclMt <- <(KMT SpLn Wrd SpLnOpt Prms? SpLnOpt Tp)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				if !_rules[ruleKMT]() {
					goto l31
				}
				if !_rules[ruleSpLn]() {
					goto l31
				}
				if !_rules[ruleWrd]() {
					goto l31
				}
				if !_rules[ruleSpLnOpt]() {
					goto l31
				}
				{
					position33, tokenIndex33 := position, tokenIndex
					if !_rules[rulePrms]() {
						goto l33
					}
					goto l34
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
			l34:
				if !_rules[ruleSpLnOpt]() {
					goto l31
				}
				if !_rules[ruleTp]() {
					goto l31
				}
				add(ruleDclMt, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 10 DclSb <- <(KSB SpLn Wrd SpLnOpt Prms? SpLnOpt Tp)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleKSB]() {
					goto l35
				}
				if !_rules[ruleSpLn]() {
					goto l35
				}
				if !_rules[ruleWrd]() {
					goto l35
				}
				if !_rules[ruleSpLnOpt]() {
					goto l35
				}
				{
					position37, tokenIndex37 := position, tokenIndex
					if !_rules[rulePrms]() {
						goto l37
					}
					goto l38
				l37:
					position, tokenIndex = position37, tokenIndex37
				}
			l38:
				if !_rules[ruleSpLnOpt]() {
					goto l35
				}
				if !_rules[ruleTp]() {
					goto l35
				}
				add(ruleDclSb, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 11 BlkEn <- <(BLK (SpOpt Wrd)* SpOpt BLKE)> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				if !_rules[ruleBLK]() {
					goto l39
				}
			l41:
				{
					position42, tokenIndex42 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l42
					}
					if !_rules[ruleWrd]() {
						goto l42
					}
					goto l41
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
				if !_rules[ruleSpOpt]() {
					goto l39
				}
				if !_rules[ruleBLKE]() {
					goto l39
				}
				add(ruleBlkEn, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 12 BlkSt <- <(BLK (SpOpt StFld)* SpOpt BLKE)> */
		func() bool {
			position43, tokenIndex43 := position, tokenIndex
			{
				position44 := position
				if !_rules[ruleBLK]() {
					goto l43
				}
			l45:
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l46
					}
					if !_rules[ruleStFld]() {
						goto l46
					}
					goto l45
				l46:
					position, tokenIndex = position46, tokenIndex46
				}
				if !_rules[ruleSpOpt]() {
					goto l43
				}
				if !_rules[ruleBLKE]() {
					goto l43
				}
				add(ruleBlkSt, position44)
			}
			return true
		l43:
			position, tokenIndex = position43, tokenIndex43
			return false
		},
		/* 13 BlkRv <- <(BLK (SpOpt RvPrp)* SpOpt BLKE)> */
		func() bool {
			position47, tokenIndex47 := position, tokenIndex
			{
				position48 := position
				if !_rules[ruleBLK]() {
					goto l47
				}
			l49:
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l50
					}
					if !_rules[ruleRvPrp]() {
						goto l50
					}
					goto l49
				l50:
					position, tokenIndex = position50, tokenIndex50
				}
				if !_rules[ruleSpOpt]() {
					goto l47
				}
				if !_rules[ruleBLKE]() {
					goto l47
				}
				add(ruleBlkRv, position48)
			}
			return true
		l47:
			position, tokenIndex = position47, tokenIndex47
			return false
		},
		/* 14 BlkUn <- <(BLK (SpOpt Wrd)+ SpOpt BLKE)> */
		func() bool {
			position51, tokenIndex51 := position, tokenIndex
			{
				position52 := position
				if !_rules[ruleBLK]() {
					goto l51
				}
				if !_rules[ruleSpOpt]() {
					goto l51
				}
				if !_rules[ruleWrd]() {
					goto l51
				}
			l53:
				{
					position54, tokenIndex54 := position, tokenIndex
					if !_rules[ruleSpOpt]() {
						goto l54
					}
					if !_rules[ruleWrd]() {
						goto l54
					}
					goto l53
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
				if !_rules[ruleSpOpt]() {
					goto l51
				}
				if !_rules[ruleBLKE]() {
					goto l51
				}
				add(ruleBlkUn, position52)
			}
			return true
		l51:
			position, tokenIndex = position51, tokenIndex51
			return false
		},
		/* 15 StFld <- <(Wrd SpLn Tp)> */
		func() bool {
			position55, tokenIndex55 := position, tokenIndex
			{
				position56 := position
				if !_rules[ruleWrd]() {
					goto l55
				}
				if !_rules[ruleSpLn]() {
					goto l55
				}
				if !_rules[ruleTp]() {
					goto l55
				}
				add(ruleStFld, position56)
			}
			return true
		l55:
			position, tokenIndex = position55, tokenIndex55
			return false
		},
		/* 16 RvPrp <- <(Wrd SpOpt (Prms SpOpt)? Tp)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if !_rules[ruleWrd]() {
					goto l57
				}
				if !_rules[ruleSpOpt]() {
					goto l57
				}
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[rulePrms]() {
						goto l59
					}
					if !_rules[ruleSpOpt]() {
						goto l59
					}
					goto l60
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
			l60:
				if !_rules[ruleTp]() {
					goto l57
				}
				add(ruleRvPrp, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 17 Prms <- <(PRN SpOpt PrmsBd? SpOpt PRNE)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[rulePRN]() {
					goto l61
				}
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				{
					position63, tokenIndex63 := position, tokenIndex
					if !_rules[rulePrmsBd]() {
						goto l63
					}
					goto l64
				l63:
					position, tokenIndex = position63, tokenIndex63
				}
			l64:
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				if !_rules[rulePRNE]() {
					goto l61
				}
				add(rulePrms, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 18 PrmsBd <- <((Prm OCM SpOpt PrmsBd) / (Prm OCM?))> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[rulePrm]() {
						goto l68
					}
					if !_rules[ruleOCM]() {
						goto l68
					}
					if !_rules[ruleSpOpt]() {
						goto l68
					}
					if !_rules[rulePrmsBd]() {
						goto l68
					}
					goto l67
				l68:
					position, tokenIndex = position67, tokenIndex67
					if !_rules[rulePrm]() {
						goto l65
					}
					{
						position69, tokenIndex69 := position, tokenIndex
						if !_rules[ruleOCM]() {
							goto l69
						}
						goto l70
					l69:
						position, tokenIndex = position69, tokenIndex69
					}
				l70:
				}
			l67:
				add(rulePrmsBd, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 19 Prm <- <(Wrd SpLn Tp)> */
		func() bool {
			position71, tokenIndex71 := position, tokenIndex
			{
				position72 := position
				if !_rules[ruleWrd]() {
					goto l71
				}
				if !_rules[ruleSpLn]() {
					goto l71
				}
				if !_rules[ruleTp]() {
					goto l71
				}
				add(rulePrm, position72)
			}
			return true
		l71:
			position, tokenIndex = position71, tokenIndex71
			return false
		},
		/* 20 Tp <- <(((ONU OLI) / ONU / OLI)* Wrd)> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
			l75:
				{
					position76, tokenIndex76 := position, tokenIndex
					{
						position77, tokenIndex77 := position, tokenIndex
						if !_rules[ruleONU]() {
							goto l78
						}
						if !_rules[ruleOLI]() {
							goto l78
						}
						goto l77
					l78:
						position, tokenIndex = position77, tokenIndex77
						if !_rules[ruleONU]() {
							goto l79
						}
						goto l77
					l79:
						position, tokenIndex = position77, tokenIndex77
						if !_rules[ruleOLI]() {
							goto l76
						}
					}
				l77:
					goto l75
				l76:
					position, tokenIndex = position76, tokenIndex76
				}
				if !_rules[ruleWrd]() {
					goto l73
				}
				add(ruleTp, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 21 Wrd <- <([a-z] / [A-Z] / [0-9] / '_')+> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				{
					position84, tokenIndex84 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l85
					}
					position++
					goto l84
				l85:
					position, tokenIndex = position84, tokenIndex84
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l86
					}
					position++
					goto l84
				l86:
					position, tokenIndex = position84, tokenIndex84
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l87
					}
					position++
					goto l84
				l87:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('_') {
						goto l80
					}
					position++
				}
			l84:
			l82:
				{
					position83, tokenIndex83 := position, tokenIndex
					{
						position88, tokenIndex88 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l89
						}
						position++
						goto l88
					l89:
						position, tokenIndex = position88, tokenIndex88
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l90
						}
						position++
						goto l88
					l90:
						position, tokenIndex = position88, tokenIndex88
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l91
						}
						position++
						goto l88
					l91:
						position, tokenIndex = position88, tokenIndex88
						if buffer[position] != rune('_') {
							goto l83
						}
						position++
					}
				l88:
					goto l82
				l83:
					position, tokenIndex = position83, tokenIndex83
				}
				add(ruleWrd, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 22 SpLn <- <(' ' / '\t')+> */
		func() bool {
			position92, tokenIndex92 := position, tokenIndex
			{
				position93 := position
				{
					position96, tokenIndex96 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l97
					}
					position++
					goto l96
				l97:
					position, tokenIndex = position96, tokenIndex96
					if buffer[position] != rune('\t') {
						goto l92
					}
					position++
				}
			l96:
			l94:
				{
					position95, tokenIndex95 := position, tokenIndex
					{
						position98, tokenIndex98 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l99
						}
						position++
						goto l98
					l99:
						position, tokenIndex = position98, tokenIndex98
						if buffer[position] != rune('\t') {
							goto l95
						}
						position++
					}
				l98:
					goto l94
				l95:
					position, tokenIndex = position95, tokenIndex95
				}
				add(ruleSpLn, position93)
			}
			return true
		l92:
			position, tokenIndex = position92, tokenIndex92
			return false
		},
		/* 23 SpOpt <- <(SpLn / SpVr)*> */
		func() bool {
			{
				position101 := position
			l102:
				{
					position103, tokenIndex103 := position, tokenIndex
					{
						position104, tokenIndex104 := position, tokenIndex
						if !_rules[ruleSpLn]() {
							goto l105
						}
						goto l104
					l105:
						position, tokenIndex = position104, tokenIndex104
						if !_rules[ruleSpVr]() {
							goto l103
						}
					}
				l104:
					goto l102
				l103:
					position, tokenIndex = position103, tokenIndex103
				}
				add(ruleSpOpt, position101)
			}
			return true
		},
		/* 24 SpLnOpt <- <(' ' / '\t')*> */
		func() bool {
			{
				position107 := position
			l108:
				{
					position109, tokenIndex109 := position, tokenIndex
					{
						position110, tokenIndex110 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l111
						}
						position++
						goto l110
					l111:
						position, tokenIndex = position110, tokenIndex110
						if buffer[position] != rune('\t') {
							goto l109
						}
						position++
					}
				l110:
					goto l108
				l109:
					position, tokenIndex = position109, tokenIndex109
				}
				add(ruleSpLnOpt, position107)
			}
			return true
		},
		/* 25 SpVr <- <('\n' / ('\r' '\n'))+> */
		func() bool {
			position112, tokenIndex112 := position, tokenIndex
			{
				position113 := position
				{
					position116, tokenIndex116 := position, tokenIndex
					if buffer[position] != rune('\n') {
						goto l117
					}
					position++
					goto l116
				l117:
					position, tokenIndex = position116, tokenIndex116
					if buffer[position] != rune('\r') {
						goto l112
					}
					position++
					if buffer[position] != rune('\n') {
						goto l112
					}
					position++
				}
			l116:
			l114:
				{
					position115, tokenIndex115 := position, tokenIndex
					{
						position118, tokenIndex118 := position, tokenIndex
						if buffer[position] != rune('\n') {
							goto l119
						}
						position++
						goto l118
					l119:
						position, tokenIndex = position118, tokenIndex118
						if buffer[position] != rune('\r') {
							goto l115
						}
						position++
						if buffer[position] != rune('\n') {
							goto l115
						}
						position++
					}
				l118:
					goto l114
				l115:
					position, tokenIndex = position115, tokenIndex115
				}
				add(ruleSpVr, position113)
			}
			return true
		l112:
			position, tokenIndex = position112, tokenIndex112
			return false
		},
		/* 26 OEQ <- <'='> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				if buffer[position] != rune('=') {
					goto l120
				}
				position++
				add(ruleOEQ, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 27 ONU <- <'?'> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('?') {
					goto l122
				}
				position++
				add(ruleONU, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 28 OLI <- <('[' ']')> */
		func() bool {
			position124, tokenIndex124 := position, tokenIndex
			{
				position125 := position
				if buffer[position] != rune('[') {
					goto l124
				}
				position++
				if buffer[position] != rune(']') {
					goto l124
				}
				position++
				add(ruleOLI, position125)
			}
			return true
		l124:
			position, tokenIndex = position124, tokenIndex124
			return false
		},
		/* 29 OCM <- <','> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune(',') {
					goto l126
				}
				position++
				add(ruleOCM, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 30 KSC <- <('s' 'c' 'h' 'e' 'm' 'a')> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if buffer[position] != rune('s') {
					goto l128
				}
				position++
				if buffer[position] != rune('c') {
					goto l128
				}
				position++
				if buffer[position] != rune('h') {
					goto l128
				}
				position++
				if buffer[position] != rune('e') {
					goto l128
				}
				position++
				if buffer[position] != rune('m') {
					goto l128
				}
				position++
				if buffer[position] != rune('a') {
					goto l128
				}
				position++
				add(ruleKSC, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 31 KAL <- <('a' 'l' 'i' 'a' 's')> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if buffer[position] != rune('a') {
					goto l130
				}
				position++
				if buffer[position] != rune('l') {
					goto l130
				}
				position++
				if buffer[position] != rune('i') {
					goto l130
				}
				position++
				if buffer[position] != rune('a') {
					goto l130
				}
				position++
				if buffer[position] != rune('s') {
					goto l130
				}
				position++
				add(ruleKAL, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 32 KEN <- <('e' 'n' 'u' 'm')> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				if buffer[position] != rune('e') {
					goto l132
				}
				position++
				if buffer[position] != rune('n') {
					goto l132
				}
				position++
				if buffer[position] != rune('u') {
					goto l132
				}
				position++
				if buffer[position] != rune('m') {
					goto l132
				}
				position++
				add(ruleKEN, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 33 KST <- <('s' 't' 'r' 'u' 'c' 't')> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if buffer[position] != rune('s') {
					goto l134
				}
				position++
				if buffer[position] != rune('t') {
					goto l134
				}
				position++
				if buffer[position] != rune('r') {
					goto l134
				}
				position++
				if buffer[position] != rune('u') {
					goto l134
				}
				position++
				if buffer[position] != rune('c') {
					goto l134
				}
				position++
				if buffer[position] != rune('t') {
					goto l134
				}
				position++
				add(ruleKST, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 34 KRV <- <('r' 'e' 's' 'o' 'l' 'v' 'e' 'r')> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if buffer[position] != rune('r') {
					goto l136
				}
				position++
				if buffer[position] != rune('e') {
					goto l136
				}
				position++
				if buffer[position] != rune('s') {
					goto l136
				}
				position++
				if buffer[position] != rune('o') {
					goto l136
				}
				position++
				if buffer[position] != rune('l') {
					goto l136
				}
				position++
				if buffer[position] != rune('v') {
					goto l136
				}
				position++
				if buffer[position] != rune('e') {
					goto l136
				}
				position++
				if buffer[position] != rune('r') {
					goto l136
				}
				position++
				add(ruleKRV, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 35 KTR <- <('t' 'r' 'a' 'i' 't')> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if buffer[position] != rune('t') {
					goto l138
				}
				position++
				if buffer[position] != rune('r') {
					goto l138
				}
				position++
				if buffer[position] != rune('a') {
					goto l138
				}
				position++
				if buffer[position] != rune('i') {
					goto l138
				}
				position++
				if buffer[position] != rune('t') {
					goto l138
				}
				position++
				add(ruleKTR, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 36 KUN <- <('u' 'n' 'i' 'o' 'n')> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != rune('u') {
					goto l140
				}
				position++
				if buffer[position] != rune('n') {
					goto l140
				}
				position++
				if buffer[position] != rune('i') {
					goto l140
				}
				position++
				if buffer[position] != rune('o') {
					goto l140
				}
				position++
				if buffer[position] != rune('n') {
					goto l140
				}
				position++
				add(ruleKUN, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 37 KQR <- <('q' 'u' 'e' 'r' 'y')> */
		func() bool {
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				if buffer[position] != rune('q') {
					goto l142
				}
				position++
				if buffer[position] != rune('u') {
					goto l142
				}
				position++
				if buffer[position] != rune('e') {
					goto l142
				}
				position++
				if buffer[position] != rune('r') {
					goto l142
				}
				position++
				if buffer[position] != rune('y') {
					goto l142
				}
				position++
				add(ruleKQR, position143)
			}
			return true
		l142:
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 38 KMT <- <('m' 'u' 't' 'a' 't' 'i' 'o' 'n')> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if buffer[position] != rune('m') {
					goto l144
				}
				position++
				if buffer[position] != rune('u') {
					goto l144
				}
				position++
				if buffer[position] != rune('t') {
					goto l144
				}
				position++
				if buffer[position] != rune('a') {
					goto l144
				}
				position++
				if buffer[position] != rune('t') {
					goto l144
				}
				position++
				if buffer[position] != rune('i') {
					goto l144
				}
				position++
				if buffer[position] != rune('o') {
					goto l144
				}
				position++
				if buffer[position] != rune('n') {
					goto l144
				}
				position++
				add(ruleKMT, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 39 KSB <- <('s' 'u' 'b' 's' 'c' 'r' 'i' 'p' 't' 'i' 'o' 'n')> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if buffer[position] != rune('s') {
					goto l146
				}
				position++
				if buffer[position] != rune('u') {
					goto l146
				}
				position++
				if buffer[position] != rune('b') {
					goto l146
				}
				position++
				if buffer[position] != rune('s') {
					goto l146
				}
				position++
				if buffer[position] != rune('c') {
					goto l146
				}
				position++
				if buffer[position] != rune('r') {
					goto l146
				}
				position++
				if buffer[position] != rune('i') {
					goto l146
				}
				position++
				if buffer[position] != rune('p') {
					goto l146
				}
				position++
				if buffer[position] != rune('t') {
					goto l146
				}
				position++
				if buffer[position] != rune('i') {
					goto l146
				}
				position++
				if buffer[position] != rune('o') {
					goto l146
				}
				position++
				if buffer[position] != rune('n') {
					goto l146
				}
				position++
				add(ruleKSB, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 40 PRN <- <'('> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				if buffer[position] != rune('(') {
					goto l148
				}
				position++
				add(rulePRN, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 41 PRNE <- <')'> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if buffer[position] != rune(')') {
					goto l150
				}
				position++
				add(rulePRNE, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 42 BLK <- <'{'> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				if buffer[position] != rune('{') {
					goto l152
				}
				position++
				add(ruleBLK, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 43 BLKE <- <'}'> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				if buffer[position] != rune('}') {
					goto l154
				}
				position++
				add(ruleBLKE, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
	}
	p.rules = _rules
	return nil
}
