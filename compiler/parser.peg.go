package compiler

// Code generated by R:\go-workspace\bin\peg.exe ./parser.peg DO NOT EDIT

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleSchema
	ruleDclSc
	ruleDclAl
	ruleDclEn
	ruleDclSt
	ruleDclRv
	ruleDclTr
	ruleDclUn
	ruleDclQr
	ruleDclMt
	ruleDclSb
	ruleBlkEn
	ruleBlkSt
	ruleBlkRv
	ruleBlkUn
	rulePropSt
	rulePropRv
	ruleArgs
	ruleTp
	ruleTpNullable
	ruleTpList
	ruleTpName
	ruleWdLowCase
	ruleSpLn
	ruleSpOpt
	ruleSpLnOpt
	ruleSpVr
	ruleOEQ
	ruleKSC
	ruleKAL
	ruleKEN
	ruleKST
	ruleKRV
	ruleKTR
	ruleKUN
	ruleKQR
	ruleKMT
	ruleKSB
	rulePRN
	rulePRNE
	ruleBLK
	ruleBLKE
)

var rul3s = [...]string{
	"Unknown",
	"Schema",
	"DclSc",
	"DclAl",
	"DclEn",
	"DclSt",
	"DclRv",
	"DclTr",
	"DclUn",
	"DclQr",
	"DclMt",
	"DclSb",
	"BlkEn",
	"BlkSt",
	"BlkRv",
	"BlkUn",
	"PropSt",
	"PropRv",
	"Args",
	"Tp",
	"TpNullable",
	"TpList",
	"TpName",
	"WdLowCase",
	"SpLn",
	"SpOpt",
	"SpLnOpt",
	"SpVr",
	"OEQ",
	"KSC",
	"KAL",
	"KEN",
	"KST",
	"KRV",
	"KTR",
	"KUN",
	"KQR",
	"KMT",
	"KSB",
	"PRN",
	"PRNE",
	"BLK",
	"BLKE",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type GAPIParser struct {
	Buffer string
	buffer []rune
	rules  [43]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *GAPIParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *GAPIParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *GAPIParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *GAPIParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *GAPIParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func Pretty(pretty bool) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *GAPIParser) Init(options ...func(*GAPIParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Schema <- <(SpOpt DclSc (SpVr+ (DclAl / DclEn / DclSt / DclTr / DclRv / DclUn / DclQr / DclMt / DclSb))+ SpOpt)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				if !_rules[ruleDclSc]() {
					goto l0
				}
				if !_rules[ruleSpVr]() {
					goto l0
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[ruleSpVr]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !_rules[ruleDclAl]() {
						goto l7
					}
					goto l6
				l7:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclEn]() {
						goto l8
					}
					goto l6
				l8:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclSt]() {
						goto l9
					}
					goto l6
				l9:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclTr]() {
						goto l10
					}
					goto l6
				l10:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclRv]() {
						goto l11
					}
					goto l6
				l11:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclUn]() {
						goto l12
					}
					goto l6
				l12:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclQr]() {
						goto l13
					}
					goto l6
				l13:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclMt]() {
						goto l14
					}
					goto l6
				l14:
					position, tokenIndex = position6, tokenIndex6
					if !_rules[ruleDclSb]() {
						goto l0
					}
				}
			l6:
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleSpVr]() {
						goto l3
					}
				l15:
					{
						position16, tokenIndex16 := position, tokenIndex
						if !_rules[ruleSpVr]() {
							goto l16
						}
						goto l15
					l16:
						position, tokenIndex = position16, tokenIndex16
					}
					{
						position17, tokenIndex17 := position, tokenIndex
						if !_rules[ruleDclAl]() {
							goto l18
						}
						goto l17
					l18:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclEn]() {
							goto l19
						}
						goto l17
					l19:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclSt]() {
							goto l20
						}
						goto l17
					l20:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclTr]() {
							goto l21
						}
						goto l17
					l21:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclRv]() {
							goto l22
						}
						goto l17
					l22:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclUn]() {
							goto l23
						}
						goto l17
					l23:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclQr]() {
							goto l24
						}
						goto l17
					l24:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclMt]() {
							goto l25
						}
						goto l17
					l25:
						position, tokenIndex = position17, tokenIndex17
						if !_rules[ruleDclSb]() {
							goto l3
						}
					}
				l17:
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				add(ruleSchema, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DclSc <- <(KSC SpLn WdLowCase)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if !_rules[ruleKSC]() {
					goto l26
				}
				if !_rules[ruleSpLn]() {
					goto l26
				}
				if !_rules[ruleWdLowCase]() {
					goto l26
				}
				add(ruleDclSc, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 2 DclAl <- <(KAL SpLn TpName SpLn OEQ SpLn TpName)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if !_rules[ruleKAL]() {
					goto l28
				}
				if !_rules[ruleSpLn]() {
					goto l28
				}
				if !_rules[ruleTpName]() {
					goto l28
				}
				if !_rules[ruleSpLn]() {
					goto l28
				}
				if !_rules[ruleOEQ]() {
					goto l28
				}
				if !_rules[ruleSpLn]() {
					goto l28
				}
				if !_rules[ruleTpName]() {
					goto l28
				}
				add(ruleDclAl, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 3 DclEn <- <(KEN SpLn TpName SpLnOpt BlkEn)> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				if !_rules[ruleKEN]() {
					goto l30
				}
				if !_rules[ruleSpLn]() {
					goto l30
				}
				if !_rules[ruleTpName]() {
					goto l30
				}
				if !_rules[ruleSpLnOpt]() {
					goto l30
				}
				if !_rules[ruleBlkEn]() {
					goto l30
				}
				add(ruleDclEn, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 4 DclSt <- <(KST SpLn TpName SpLnOpt BlkSt)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if !_rules[ruleKST]() {
					goto l32
				}
				if !_rules[ruleSpLn]() {
					goto l32
				}
				if !_rules[ruleTpName]() {
					goto l32
				}
				if !_rules[ruleSpLnOpt]() {
					goto l32
				}
				if !_rules[ruleBlkSt]() {
					goto l32
				}
				add(ruleDclSt, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 5 DclRv <- <(KRV SpLn TpName SpLnOpt BlkRv)> */
		func() bool {
			position34, tokenIndex34 := position, tokenIndex
			{
				position35 := position
				if !_rules[ruleKRV]() {
					goto l34
				}
				if !_rules[ruleSpLn]() {
					goto l34
				}
				if !_rules[ruleTpName]() {
					goto l34
				}
				if !_rules[ruleSpLnOpt]() {
					goto l34
				}
				if !_rules[ruleBlkRv]() {
					goto l34
				}
				add(ruleDclRv, position35)
			}
			return true
		l34:
			position, tokenIndex = position34, tokenIndex34
			return false
		},
		/* 6 DclTr <- <(KTR SpLn TpName SpLnOpt BlkRv)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if !_rules[ruleKTR]() {
					goto l36
				}
				if !_rules[ruleSpLn]() {
					goto l36
				}
				if !_rules[ruleTpName]() {
					goto l36
				}
				if !_rules[ruleSpLnOpt]() {
					goto l36
				}
				if !_rules[ruleBlkRv]() {
					goto l36
				}
				add(ruleDclTr, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 7 DclUn <- <(KUN SpLn TpName SpLnOpt BlkUn)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				if !_rules[ruleKUN]() {
					goto l38
				}
				if !_rules[ruleSpLn]() {
					goto l38
				}
				if !_rules[ruleTpName]() {
					goto l38
				}
				if !_rules[ruleSpLnOpt]() {
					goto l38
				}
				if !_rules[ruleBlkUn]() {
					goto l38
				}
				add(ruleDclUn, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 8 DclQr <- <(KQR SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				if !_rules[ruleKQR]() {
					goto l40
				}
				if !_rules[ruleSpLn]() {
					goto l40
				}
				if !_rules[ruleWdLowCase]() {
					goto l40
				}
				if !_rules[ruleSpLnOpt]() {
					goto l40
				}
				{
					position42, tokenIndex42 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l42
					}
					goto l43
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
			l43:
				if !_rules[ruleSpLnOpt]() {
					goto l40
				}
				if !_rules[ruleTp]() {
					goto l40
				}
				add(ruleDclQr, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 9 DclMt <- <(KMT SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position44, tokenIndex44 := position, tokenIndex
			{
				position45 := position
				if !_rules[ruleKMT]() {
					goto l44
				}
				if !_rules[ruleSpLn]() {
					goto l44
				}
				if !_rules[ruleWdLowCase]() {
					goto l44
				}
				if !_rules[ruleSpLnOpt]() {
					goto l44
				}
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l46
					}
					goto l47
				l46:
					position, tokenIndex = position46, tokenIndex46
				}
			l47:
				if !_rules[ruleSpLnOpt]() {
					goto l44
				}
				if !_rules[ruleTp]() {
					goto l44
				}
				add(ruleDclMt, position45)
			}
			return true
		l44:
			position, tokenIndex = position44, tokenIndex44
			return false
		},
		/* 10 DclSb <- <(KSB SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleKSB]() {
					goto l48
				}
				if !_rules[ruleSpLn]() {
					goto l48
				}
				if !_rules[ruleWdLowCase]() {
					goto l48
				}
				if !_rules[ruleSpLnOpt]() {
					goto l48
				}
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l50
					}
					goto l51
				l50:
					position, tokenIndex = position50, tokenIndex50
				}
			l51:
				if !_rules[ruleSpLnOpt]() {
					goto l48
				}
				if !_rules[ruleTp]() {
					goto l48
				}
				add(ruleDclSb, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 11 BlkEn <- <(BLK SpOpt WdLowCase+ SpOpt BLKE)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleBLK]() {
					goto l52
				}
				if !_rules[ruleSpOpt]() {
					goto l52
				}
				if !_rules[ruleWdLowCase]() {
					goto l52
				}
			l54:
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleWdLowCase]() {
						goto l55
					}
					goto l54
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
				if !_rules[ruleSpOpt]() {
					goto l52
				}
				if !_rules[ruleBLKE]() {
					goto l52
				}
				add(ruleBlkEn, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 BlkSt <- <(BLK SpOpt PropSt+ SpOpt BLKE)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleBLK]() {
					goto l56
				}
				if !_rules[ruleSpOpt]() {
					goto l56
				}
				if !_rules[rulePropSt]() {
					goto l56
				}
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[rulePropSt]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				if !_rules[ruleSpOpt]() {
					goto l56
				}
				if !_rules[ruleBLKE]() {
					goto l56
				}
				add(ruleBlkSt, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 BlkRv <- <(BLK SpOpt PropRv+ SpOpt BLKE)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if !_rules[ruleBLK]() {
					goto l60
				}
				if !_rules[ruleSpOpt]() {
					goto l60
				}
				if !_rules[rulePropRv]() {
					goto l60
				}
			l62:
				{
					position63, tokenIndex63 := position, tokenIndex
					if !_rules[rulePropRv]() {
						goto l63
					}
					goto l62
				l63:
					position, tokenIndex = position63, tokenIndex63
				}
				if !_rules[ruleSpOpt]() {
					goto l60
				}
				if !_rules[ruleBLKE]() {
					goto l60
				}
				add(ruleBlkRv, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 BlkUn <- <(BLK SpOpt TpName+ SpOpt BLKE)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if !_rules[ruleBLK]() {
					goto l64
				}
				if !_rules[ruleSpOpt]() {
					goto l64
				}
				if !_rules[ruleTpName]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleTpName]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				if !_rules[ruleSpOpt]() {
					goto l64
				}
				if !_rules[ruleBLKE]() {
					goto l64
				}
				add(ruleBlkUn, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 PropSt <- <(WdLowCase SpLn Tp)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if !_rules[ruleWdLowCase]() {
					goto l68
				}
				if !_rules[ruleSpLn]() {
					goto l68
				}
				if !_rules[ruleTp]() {
					goto l68
				}
				add(rulePropSt, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 16 PropRv <- <(WdLowCase SpLn Args? Tp)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				if !_rules[ruleWdLowCase]() {
					goto l70
				}
				if !_rules[ruleSpLn]() {
					goto l70
				}
				{
					position72, tokenIndex72 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l72
					}
					goto l73
				l72:
					position, tokenIndex = position72, tokenIndex72
				}
			l73:
				if !_rules[ruleTp]() {
					goto l70
				}
				add(rulePropRv, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 17 Args <- <(PRN SpOpt (WdLowCase Tp ',')+ SpOpt PRNE)> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
				if !_rules[rulePRN]() {
					goto l74
				}
				if !_rules[ruleSpOpt]() {
					goto l74
				}
				if !_rules[ruleWdLowCase]() {
					goto l74
				}
				if !_rules[ruleTp]() {
					goto l74
				}
				if buffer[position] != rune(',') {
					goto l74
				}
				position++
			l76:
				{
					position77, tokenIndex77 := position, tokenIndex
					if !_rules[ruleWdLowCase]() {
						goto l77
					}
					if !_rules[ruleTp]() {
						goto l77
					}
					if buffer[position] != rune(',') {
						goto l77
					}
					position++
					goto l76
				l77:
					position, tokenIndex = position77, tokenIndex77
				}
				if !_rules[ruleSpOpt]() {
					goto l74
				}
				if !_rules[rulePRNE]() {
					goto l74
				}
				add(ruleArgs, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 18 Tp <- <(TpName / TpNullable / TpList)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				{
					position80, tokenIndex80 := position, tokenIndex
					if !_rules[ruleTpName]() {
						goto l81
					}
					goto l80
				l81:
					position, tokenIndex = position80, tokenIndex80
					if !_rules[ruleTpNullable]() {
						goto l82
					}
					goto l80
				l82:
					position, tokenIndex = position80, tokenIndex80
					if !_rules[ruleTpList]() {
						goto l78
					}
				}
			l80:
				add(ruleTp, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 19 TpNullable <- <('?' Tp)> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				if buffer[position] != rune('?') {
					goto l83
				}
				position++
				if !_rules[ruleTp]() {
					goto l83
				}
				add(ruleTpNullable, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 20 TpList <- <('[' ']' Tp)> */
		func() bool {
			position85, tokenIndex85 := position, tokenIndex
			{
				position86 := position
				if buffer[position] != rune('[') {
					goto l85
				}
				position++
				if buffer[position] != rune(']') {
					goto l85
				}
				position++
				if !_rules[ruleTp]() {
					goto l85
				}
				add(ruleTpList, position86)
			}
			return true
		l85:
			position, tokenIndex = position85, tokenIndex85
			return false
		},
		/* 21 TpName <- <([A-Z] ([a-z] / [A-Z] / [0-9])*)> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l87
				}
				position++
			l89:
				{
					position90, tokenIndex90 := position, tokenIndex
					{
						position91, tokenIndex91 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l92
						}
						position++
						goto l91
					l92:
						position, tokenIndex = position91, tokenIndex91
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l93
						}
						position++
						goto l91
					l93:
						position, tokenIndex = position91, tokenIndex91
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l90
						}
						position++
					}
				l91:
					goto l89
				l90:
					position, tokenIndex = position90, tokenIndex90
				}
				add(ruleTpName, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 22 WdLowCase <- <([a-z] ([a-z] / [A-Z] / [0-9])*)> */
		func() bool {
			position94, tokenIndex94 := position, tokenIndex
			{
				position95 := position
				if c := buffer[position]; c < rune('a') || c > rune('z') {
					goto l94
				}
				position++
			l96:
				{
					position97, tokenIndex97 := position, tokenIndex
					{
						position98, tokenIndex98 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l99
						}
						position++
						goto l98
					l99:
						position, tokenIndex = position98, tokenIndex98
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l100
						}
						position++
						goto l98
					l100:
						position, tokenIndex = position98, tokenIndex98
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l97
						}
						position++
					}
				l98:
					goto l96
				l97:
					position, tokenIndex = position97, tokenIndex97
				}
				add(ruleWdLowCase, position95)
			}
			return true
		l94:
			position, tokenIndex = position94, tokenIndex94
			return false
		},
		/* 23 SpLn <- <(' ' / '\t')+> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				{
					position105, tokenIndex105 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l106
					}
					position++
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if buffer[position] != rune('\t') {
						goto l101
					}
					position++
				}
			l105:
			l103:
				{
					position104, tokenIndex104 := position, tokenIndex
					{
						position107, tokenIndex107 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l108
						}
						position++
						goto l107
					l108:
						position, tokenIndex = position107, tokenIndex107
						if buffer[position] != rune('\t') {
							goto l104
						}
						position++
					}
				l107:
					goto l103
				l104:
					position, tokenIndex = position104, tokenIndex104
				}
				add(ruleSpLn, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 24 SpOpt <- <(SpLn / SpVr)*> */
		func() bool {
			{
				position110 := position
			l111:
				{
					position112, tokenIndex112 := position, tokenIndex
					{
						position113, tokenIndex113 := position, tokenIndex
						if !_rules[ruleSpLn]() {
							goto l114
						}
						goto l113
					l114:
						position, tokenIndex = position113, tokenIndex113
						if !_rules[ruleSpVr]() {
							goto l112
						}
					}
				l113:
					goto l111
				l112:
					position, tokenIndex = position112, tokenIndex112
				}
				add(ruleSpOpt, position110)
			}
			return true
		},
		/* 25 SpLnOpt <- <(' ' / '\t')*> */
		func() bool {
			{
				position116 := position
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					{
						position119, tokenIndex119 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l120
						}
						position++
						goto l119
					l120:
						position, tokenIndex = position119, tokenIndex119
						if buffer[position] != rune('\t') {
							goto l118
						}
						position++
					}
				l119:
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(ruleSpLnOpt, position116)
			}
			return true
		},
		/* 26 SpVr <- <('\n' / ('\r' '\n'))+> */
		func() bool {
			position121, tokenIndex121 := position, tokenIndex
			{
				position122 := position
				{
					position125, tokenIndex125 := position, tokenIndex
					if buffer[position] != rune('\n') {
						goto l126
					}
					position++
					goto l125
				l126:
					position, tokenIndex = position125, tokenIndex125
					if buffer[position] != rune('\r') {
						goto l121
					}
					position++
					if buffer[position] != rune('\n') {
						goto l121
					}
					position++
				}
			l125:
			l123:
				{
					position124, tokenIndex124 := position, tokenIndex
					{
						position127, tokenIndex127 := position, tokenIndex
						if buffer[position] != rune('\n') {
							goto l128
						}
						position++
						goto l127
					l128:
						position, tokenIndex = position127, tokenIndex127
						if buffer[position] != rune('\r') {
							goto l124
						}
						position++
						if buffer[position] != rune('\n') {
							goto l124
						}
						position++
					}
				l127:
					goto l123
				l124:
					position, tokenIndex = position124, tokenIndex124
				}
				add(ruleSpVr, position122)
			}
			return true
		l121:
			position, tokenIndex = position121, tokenIndex121
			return false
		},
		/* 27 OEQ <- <'='> */
		func() bool {
			position129, tokenIndex129 := position, tokenIndex
			{
				position130 := position
				if buffer[position] != rune('=') {
					goto l129
				}
				position++
				add(ruleOEQ, position130)
			}
			return true
		l129:
			position, tokenIndex = position129, tokenIndex129
			return false
		},
		/* 28 KSC <- <('s' 'c' 'h' 'e' 'm' 'a')> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune('s') {
					goto l131
				}
				position++
				if buffer[position] != rune('c') {
					goto l131
				}
				position++
				if buffer[position] != rune('h') {
					goto l131
				}
				position++
				if buffer[position] != rune('e') {
					goto l131
				}
				position++
				if buffer[position] != rune('m') {
					goto l131
				}
				position++
				if buffer[position] != rune('a') {
					goto l131
				}
				position++
				add(ruleKSC, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 29 KAL <- <('a' 'l' 'i' 'a' 's')> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if buffer[position] != rune('a') {
					goto l133
				}
				position++
				if buffer[position] != rune('l') {
					goto l133
				}
				position++
				if buffer[position] != rune('i') {
					goto l133
				}
				position++
				if buffer[position] != rune('a') {
					goto l133
				}
				position++
				if buffer[position] != rune('s') {
					goto l133
				}
				position++
				add(ruleKAL, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 30 KEN <- <('e' 'n' 'u' 'm')> */
		func() bool {
			position135, tokenIndex135 := position, tokenIndex
			{
				position136 := position
				if buffer[position] != rune('e') {
					goto l135
				}
				position++
				if buffer[position] != rune('n') {
					goto l135
				}
				position++
				if buffer[position] != rune('u') {
					goto l135
				}
				position++
				if buffer[position] != rune('m') {
					goto l135
				}
				position++
				add(ruleKEN, position136)
			}
			return true
		l135:
			position, tokenIndex = position135, tokenIndex135
			return false
		},
		/* 31 KST <- <('s' 't' 'r' 'u' 'c' 't')> */
		func() bool {
			position137, tokenIndex137 := position, tokenIndex
			{
				position138 := position
				if buffer[position] != rune('s') {
					goto l137
				}
				position++
				if buffer[position] != rune('t') {
					goto l137
				}
				position++
				if buffer[position] != rune('r') {
					goto l137
				}
				position++
				if buffer[position] != rune('u') {
					goto l137
				}
				position++
				if buffer[position] != rune('c') {
					goto l137
				}
				position++
				if buffer[position] != rune('t') {
					goto l137
				}
				position++
				add(ruleKST, position138)
			}
			return true
		l137:
			position, tokenIndex = position137, tokenIndex137
			return false
		},
		/* 32 KRV <- <('r' 'e' 's' 'o' 'l' 'v' 'e' 'r')> */
		func() bool {
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				if buffer[position] != rune('r') {
					goto l139
				}
				position++
				if buffer[position] != rune('e') {
					goto l139
				}
				position++
				if buffer[position] != rune('s') {
					goto l139
				}
				position++
				if buffer[position] != rune('o') {
					goto l139
				}
				position++
				if buffer[position] != rune('l') {
					goto l139
				}
				position++
				if buffer[position] != rune('v') {
					goto l139
				}
				position++
				if buffer[position] != rune('e') {
					goto l139
				}
				position++
				if buffer[position] != rune('r') {
					goto l139
				}
				position++
				add(ruleKRV, position140)
			}
			return true
		l139:
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 33 KTR <- <('t' 'r' 'a' 'i' 't')> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				if buffer[position] != rune('t') {
					goto l141
				}
				position++
				if buffer[position] != rune('r') {
					goto l141
				}
				position++
				if buffer[position] != rune('a') {
					goto l141
				}
				position++
				if buffer[position] != rune('i') {
					goto l141
				}
				position++
				if buffer[position] != rune('t') {
					goto l141
				}
				position++
				add(ruleKTR, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 34 KUN <- <('u' 'n' 'i' 'o' 'n')> */
		func() bool {
			position143, tokenIndex143 := position, tokenIndex
			{
				position144 := position
				if buffer[position] != rune('u') {
					goto l143
				}
				position++
				if buffer[position] != rune('n') {
					goto l143
				}
				position++
				if buffer[position] != rune('i') {
					goto l143
				}
				position++
				if buffer[position] != rune('o') {
					goto l143
				}
				position++
				if buffer[position] != rune('n') {
					goto l143
				}
				position++
				add(ruleKUN, position144)
			}
			return true
		l143:
			position, tokenIndex = position143, tokenIndex143
			return false
		},
		/* 35 KQR <- <('q' 'u' 'e' 'r' 'y')> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('q') {
					goto l145
				}
				position++
				if buffer[position] != rune('u') {
					goto l145
				}
				position++
				if buffer[position] != rune('e') {
					goto l145
				}
				position++
				if buffer[position] != rune('r') {
					goto l145
				}
				position++
				if buffer[position] != rune('y') {
					goto l145
				}
				position++
				add(ruleKQR, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 36 KMT <- <('m' 'u' 't' 'a' 't' 'i' 'o' 'n')> */
		func() bool {
			position147, tokenIndex147 := position, tokenIndex
			{
				position148 := position
				if buffer[position] != rune('m') {
					goto l147
				}
				position++
				if buffer[position] != rune('u') {
					goto l147
				}
				position++
				if buffer[position] != rune('t') {
					goto l147
				}
				position++
				if buffer[position] != rune('a') {
					goto l147
				}
				position++
				if buffer[position] != rune('t') {
					goto l147
				}
				position++
				if buffer[position] != rune('i') {
					goto l147
				}
				position++
				if buffer[position] != rune('o') {
					goto l147
				}
				position++
				if buffer[position] != rune('n') {
					goto l147
				}
				position++
				add(ruleKMT, position148)
			}
			return true
		l147:
			position, tokenIndex = position147, tokenIndex147
			return false
		},
		/* 37 KSB <- <('s' 'u' 'b' 's' 'c' 'r' 'i' 'p' 't' 'i' 'o' 'n')> */
		func() bool {
			position149, tokenIndex149 := position, tokenIndex
			{
				position150 := position
				if buffer[position] != rune('s') {
					goto l149
				}
				position++
				if buffer[position] != rune('u') {
					goto l149
				}
				position++
				if buffer[position] != rune('b') {
					goto l149
				}
				position++
				if buffer[position] != rune('s') {
					goto l149
				}
				position++
				if buffer[position] != rune('c') {
					goto l149
				}
				position++
				if buffer[position] != rune('r') {
					goto l149
				}
				position++
				if buffer[position] != rune('i') {
					goto l149
				}
				position++
				if buffer[position] != rune('p') {
					goto l149
				}
				position++
				if buffer[position] != rune('t') {
					goto l149
				}
				position++
				if buffer[position] != rune('i') {
					goto l149
				}
				position++
				if buffer[position] != rune('o') {
					goto l149
				}
				position++
				if buffer[position] != rune('n') {
					goto l149
				}
				position++
				add(ruleKSB, position150)
			}
			return true
		l149:
			position, tokenIndex = position149, tokenIndex149
			return false
		},
		/* 38 PRN <- <'('> */
		func() bool {
			position151, tokenIndex151 := position, tokenIndex
			{
				position152 := position
				if buffer[position] != rune('(') {
					goto l151
				}
				position++
				add(rulePRN, position152)
			}
			return true
		l151:
			position, tokenIndex = position151, tokenIndex151
			return false
		},
		/* 39 PRNE <- <')'> */
		func() bool {
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				if buffer[position] != rune(')') {
					goto l153
				}
				position++
				add(rulePRNE, position154)
			}
			return true
		l153:
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 40 BLK <- <'{'> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				if buffer[position] != rune('{') {
					goto l155
				}
				position++
				add(ruleBLK, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 41 BLKE <- <'}'> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				if buffer[position] != rune('}') {
					goto l157
				}
				position++
				add(ruleBLKE, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
	}
	p.rules = _rules
	return nil
}
