package main

// Code generated by R:\go-workspace\bin\peg.exe -strict ./parser.peg DO NOT EDIT

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleSchema
	ruleDclSchema
	ruleDclAl
	ruleDclEn
	ruleDclSt
	ruleDclRv
	ruleDclTr
	ruleDclUn
	ruleDclQr
	ruleDclMt
	ruleDclSb
	ruleBlkEn
	ruleBlkSt
	ruleBlkRv
	ruleBlkUn
	rulePropSt
	rulePropRv
	ruleArgs
	ruleTp
	ruleTpNullable
	ruleTpList
	ruleTpName
	ruleWdLowCase
	ruleSpLn
	ruleSpOpt
	ruleSpLnOpt
	ruleSpVr
	ruleOEQ
	ruleKSCM
	ruleKEN
	ruleKST
	ruleKRV
	ruleKTR
	ruleKUN
	ruleKQR
	ruleKMT
	ruleKSB
	rulePRN
	rulePRNE
	ruleBLK
	ruleBLKE
)

var rul3s = [...]string{
	"Unknown",
	"Schema",
	"DclSchema",
	"DclAl",
	"DclEn",
	"DclSt",
	"DclRv",
	"DclTr",
	"DclUn",
	"DclQr",
	"DclMt",
	"DclSb",
	"BlkEn",
	"BlkSt",
	"BlkRv",
	"BlkUn",
	"PropSt",
	"PropRv",
	"Args",
	"Tp",
	"TpNullable",
	"TpList",
	"TpName",
	"WdLowCase",
	"SpLn",
	"SpOpt",
	"SpLnOpt",
	"SpVr",
	"OEQ",
	"KSCM",
	"KEN",
	"KST",
	"KRV",
	"KTR",
	"KUN",
	"KQR",
	"KMT",
	"KSB",
	"PRN",
	"PRNE",
	"BLK",
	"BLKE",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type GAPIParser struct {
	Buffer string
	buffer []rune
	rules  [42]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *GAPIParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *GAPIParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *GAPIParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *GAPIParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *GAPIParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func Pretty(pretty bool) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*GAPIParser) error {
	return func(p *GAPIParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *GAPIParser) Init(options ...func(*GAPIParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Schema <- <(DclSchema (SpVr (DclAl / DclEn / DclSt / DclTr / DclRv / DclUn / DclQr / DclMt / DclSb))+ SpOpt !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleDclSchema]() {
					goto l0
				}
				if !_rules[ruleSpVr]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[ruleDclAl]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclEn]() {
						goto l6
					}
					goto l4
				l6:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclSt]() {
						goto l7
					}
					goto l4
				l7:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclTr]() {
						goto l8
					}
					goto l4
				l8:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclRv]() {
						goto l9
					}
					goto l4
				l9:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclUn]() {
						goto l10
					}
					goto l4
				l10:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclQr]() {
						goto l11
					}
					goto l4
				l11:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclMt]() {
						goto l12
					}
					goto l4
				l12:
					position, tokenIndex = position4, tokenIndex4
					if !_rules[ruleDclSb]() {
						goto l0
					}
				}
			l4:
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleSpVr]() {
						goto l3
					}
					{
						position13, tokenIndex13 := position, tokenIndex
						if !_rules[ruleDclAl]() {
							goto l14
						}
						goto l13
					l14:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclEn]() {
							goto l15
						}
						goto l13
					l15:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclSt]() {
							goto l16
						}
						goto l13
					l16:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclTr]() {
							goto l17
						}
						goto l13
					l17:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclRv]() {
							goto l18
						}
						goto l13
					l18:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclUn]() {
							goto l19
						}
						goto l13
					l19:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclQr]() {
							goto l20
						}
						goto l13
					l20:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclMt]() {
							goto l21
						}
						goto l13
					l21:
						position, tokenIndex = position13, tokenIndex13
						if !_rules[ruleDclSb]() {
							goto l3
						}
					}
				l13:
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[ruleSpOpt]() {
					goto l0
				}
				{
					position22, tokenIndex22 := position, tokenIndex
					if !matchDot() {
						goto l22
					}
					goto l0
				l22:
					position, tokenIndex = position22, tokenIndex22
				}
				add(ruleSchema, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 DclSchema <- <(KSCM SpLn WdLowCase)> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if !_rules[ruleKSCM]() {
					goto l23
				}
				if !_rules[ruleSpLn]() {
					goto l23
				}
				if !_rules[ruleWdLowCase]() {
					goto l23
				}
				add(ruleDclSchema, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 2 DclAl <- <(TpName SpLn OEQ SpLn TpName)> */
		func() bool {
			position25, tokenIndex25 := position, tokenIndex
			{
				position26 := position
				if !_rules[ruleTpName]() {
					goto l25
				}
				if !_rules[ruleSpLn]() {
					goto l25
				}
				if !_rules[ruleOEQ]() {
					goto l25
				}
				if !_rules[ruleSpLn]() {
					goto l25
				}
				if !_rules[ruleTpName]() {
					goto l25
				}
				add(ruleDclAl, position26)
			}
			return true
		l25:
			position, tokenIndex = position25, tokenIndex25
			return false
		},
		/* 3 DclEn <- <(KEN SpLn TpName SpLnOpt BlkEn)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[ruleKEN]() {
					goto l27
				}
				if !_rules[ruleSpLn]() {
					goto l27
				}
				if !_rules[ruleTpName]() {
					goto l27
				}
				if !_rules[ruleSpLnOpt]() {
					goto l27
				}
				if !_rules[ruleBlkEn]() {
					goto l27
				}
				add(ruleDclEn, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 4 DclSt <- <(KST SpLn TpName SpLnOpt BlkSt)> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				if !_rules[ruleKST]() {
					goto l29
				}
				if !_rules[ruleSpLn]() {
					goto l29
				}
				if !_rules[ruleTpName]() {
					goto l29
				}
				if !_rules[ruleSpLnOpt]() {
					goto l29
				}
				if !_rules[ruleBlkSt]() {
					goto l29
				}
				add(ruleDclSt, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 5 DclRv <- <(KRV SpLn TpName SpLnOpt BlkRv)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				if !_rules[ruleKRV]() {
					goto l31
				}
				if !_rules[ruleSpLn]() {
					goto l31
				}
				if !_rules[ruleTpName]() {
					goto l31
				}
				if !_rules[ruleSpLnOpt]() {
					goto l31
				}
				if !_rules[ruleBlkRv]() {
					goto l31
				}
				add(ruleDclRv, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 6 DclTr <- <(KTR SpLn TpName SpLnOpt BlkRv)> */
		func() bool {
			position33, tokenIndex33 := position, tokenIndex
			{
				position34 := position
				if !_rules[ruleKTR]() {
					goto l33
				}
				if !_rules[ruleSpLn]() {
					goto l33
				}
				if !_rules[ruleTpName]() {
					goto l33
				}
				if !_rules[ruleSpLnOpt]() {
					goto l33
				}
				if !_rules[ruleBlkRv]() {
					goto l33
				}
				add(ruleDclTr, position34)
			}
			return true
		l33:
			position, tokenIndex = position33, tokenIndex33
			return false
		},
		/* 7 DclUn <- <(KUN SpLn TpName SpLnOpt BlkUn)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleKUN]() {
					goto l35
				}
				if !_rules[ruleSpLn]() {
					goto l35
				}
				if !_rules[ruleTpName]() {
					goto l35
				}
				if !_rules[ruleSpLnOpt]() {
					goto l35
				}
				if !_rules[ruleBlkUn]() {
					goto l35
				}
				add(ruleDclUn, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 8 DclQr <- <(KQR SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				if !_rules[ruleKQR]() {
					goto l37
				}
				if !_rules[ruleSpLn]() {
					goto l37
				}
				if !_rules[ruleWdLowCase]() {
					goto l37
				}
				if !_rules[ruleSpLnOpt]() {
					goto l37
				}
				{
					position39, tokenIndex39 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l39
					}
					goto l40
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
			l40:
				if !_rules[ruleSpLnOpt]() {
					goto l37
				}
				if !_rules[ruleTp]() {
					goto l37
				}
				add(ruleDclQr, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 9 DclMt <- <(KMT SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				if !_rules[ruleKMT]() {
					goto l41
				}
				if !_rules[ruleSpLn]() {
					goto l41
				}
				if !_rules[ruleWdLowCase]() {
					goto l41
				}
				if !_rules[ruleSpLnOpt]() {
					goto l41
				}
				{
					position43, tokenIndex43 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l43
					}
					goto l44
				l43:
					position, tokenIndex = position43, tokenIndex43
				}
			l44:
				if !_rules[ruleSpLnOpt]() {
					goto l41
				}
				if !_rules[ruleTp]() {
					goto l41
				}
				add(ruleDclMt, position42)
			}
			return true
		l41:
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 10 DclSb <- <(KSB SpLn WdLowCase SpLnOpt Args? SpLnOpt Tp)> */
		func() bool {
			position45, tokenIndex45 := position, tokenIndex
			{
				position46 := position
				if !_rules[ruleKSB]() {
					goto l45
				}
				if !_rules[ruleSpLn]() {
					goto l45
				}
				if !_rules[ruleWdLowCase]() {
					goto l45
				}
				if !_rules[ruleSpLnOpt]() {
					goto l45
				}
				{
					position47, tokenIndex47 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l47
					}
					goto l48
				l47:
					position, tokenIndex = position47, tokenIndex47
				}
			l48:
				if !_rules[ruleSpLnOpt]() {
					goto l45
				}
				if !_rules[ruleTp]() {
					goto l45
				}
				add(ruleDclSb, position46)
			}
			return true
		l45:
			position, tokenIndex = position45, tokenIndex45
			return false
		},
		/* 11 BlkEn <- <(BLK SpOpt WdLowCase+ SpOpt BLKE)> */
		func() bool {
			position49, tokenIndex49 := position, tokenIndex
			{
				position50 := position
				if !_rules[ruleBLK]() {
					goto l49
				}
				if !_rules[ruleSpOpt]() {
					goto l49
				}
				if !_rules[ruleWdLowCase]() {
					goto l49
				}
			l51:
				{
					position52, tokenIndex52 := position, tokenIndex
					if !_rules[ruleWdLowCase]() {
						goto l52
					}
					goto l51
				l52:
					position, tokenIndex = position52, tokenIndex52
				}
				if !_rules[ruleSpOpt]() {
					goto l49
				}
				if !_rules[ruleBLKE]() {
					goto l49
				}
				add(ruleBlkEn, position50)
			}
			return true
		l49:
			position, tokenIndex = position49, tokenIndex49
			return false
		},
		/* 12 BlkSt <- <(BLK SpOpt PropSt+ SpOpt BLKE)> */
		func() bool {
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				if !_rules[ruleBLK]() {
					goto l53
				}
				if !_rules[ruleSpOpt]() {
					goto l53
				}
				if !_rules[rulePropSt]() {
					goto l53
				}
			l55:
				{
					position56, tokenIndex56 := position, tokenIndex
					if !_rules[rulePropSt]() {
						goto l56
					}
					goto l55
				l56:
					position, tokenIndex = position56, tokenIndex56
				}
				if !_rules[ruleSpOpt]() {
					goto l53
				}
				if !_rules[ruleBLKE]() {
					goto l53
				}
				add(ruleBlkSt, position54)
			}
			return true
		l53:
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 13 BlkRv <- <(BLK SpOpt PropRv+ SpOpt BLKE)> */
		func() bool {
			position57, tokenIndex57 := position, tokenIndex
			{
				position58 := position
				if !_rules[ruleBLK]() {
					goto l57
				}
				if !_rules[ruleSpOpt]() {
					goto l57
				}
				if !_rules[rulePropRv]() {
					goto l57
				}
			l59:
				{
					position60, tokenIndex60 := position, tokenIndex
					if !_rules[rulePropRv]() {
						goto l60
					}
					goto l59
				l60:
					position, tokenIndex = position60, tokenIndex60
				}
				if !_rules[ruleSpOpt]() {
					goto l57
				}
				if !_rules[ruleBLKE]() {
					goto l57
				}
				add(ruleBlkRv, position58)
			}
			return true
		l57:
			position, tokenIndex = position57, tokenIndex57
			return false
		},
		/* 14 BlkUn <- <(BLK SpOpt TpName+ SpOpt BLKE)> */
		func() bool {
			position61, tokenIndex61 := position, tokenIndex
			{
				position62 := position
				if !_rules[ruleBLK]() {
					goto l61
				}
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				if !_rules[ruleTpName]() {
					goto l61
				}
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleTpName]() {
						goto l64
					}
					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
				if !_rules[ruleSpOpt]() {
					goto l61
				}
				if !_rules[ruleBLKE]() {
					goto l61
				}
				add(ruleBlkUn, position62)
			}
			return true
		l61:
			position, tokenIndex = position61, tokenIndex61
			return false
		},
		/* 15 PropSt <- <(WdLowCase SpLn Tp)> */
		func() bool {
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				if !_rules[ruleWdLowCase]() {
					goto l65
				}
				if !_rules[ruleSpLn]() {
					goto l65
				}
				if !_rules[ruleTp]() {
					goto l65
				}
				add(rulePropSt, position66)
			}
			return true
		l65:
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 16 PropRv <- <(WdLowCase SpLn Args? Tp)> */
		func() bool {
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				if !_rules[ruleWdLowCase]() {
					goto l67
				}
				if !_rules[ruleSpLn]() {
					goto l67
				}
				{
					position69, tokenIndex69 := position, tokenIndex
					if !_rules[ruleArgs]() {
						goto l69
					}
					goto l70
				l69:
					position, tokenIndex = position69, tokenIndex69
				}
			l70:
				if !_rules[ruleTp]() {
					goto l67
				}
				add(rulePropRv, position68)
			}
			return true
		l67:
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 17 Args <- <(PRN SpOpt (WdLowCase Tp ',')+ SpOpt PRNE)> */
		func() bool {
			position71, tokenIndex71 := position, tokenIndex
			{
				position72 := position
				if !_rules[rulePRN]() {
					goto l71
				}
				if !_rules[ruleSpOpt]() {
					goto l71
				}
				if !_rules[ruleWdLowCase]() {
					goto l71
				}
				if !_rules[ruleTp]() {
					goto l71
				}
				if buffer[position] != rune(',') {
					goto l71
				}
				position++
			l73:
				{
					position74, tokenIndex74 := position, tokenIndex
					if !_rules[ruleWdLowCase]() {
						goto l74
					}
					if !_rules[ruleTp]() {
						goto l74
					}
					if buffer[position] != rune(',') {
						goto l74
					}
					position++
					goto l73
				l74:
					position, tokenIndex = position74, tokenIndex74
				}
				if !_rules[ruleSpOpt]() {
					goto l71
				}
				if !_rules[rulePRNE]() {
					goto l71
				}
				add(ruleArgs, position72)
			}
			return true
		l71:
			position, tokenIndex = position71, tokenIndex71
			return false
		},
		/* 18 Tp <- <(TpName / TpNullable / TpList)> */
		func() bool {
			position75, tokenIndex75 := position, tokenIndex
			{
				position76 := position
				{
					position77, tokenIndex77 := position, tokenIndex
					if !_rules[ruleTpName]() {
						goto l78
					}
					goto l77
				l78:
					position, tokenIndex = position77, tokenIndex77
					if !_rules[ruleTpNullable]() {
						goto l79
					}
					goto l77
				l79:
					position, tokenIndex = position77, tokenIndex77
					if !_rules[ruleTpList]() {
						goto l75
					}
				}
			l77:
				add(ruleTp, position76)
			}
			return true
		l75:
			position, tokenIndex = position75, tokenIndex75
			return false
		},
		/* 19 TpNullable <- <('?' Tp)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				if buffer[position] != rune('?') {
					goto l80
				}
				position++
				if !_rules[ruleTp]() {
					goto l80
				}
				add(ruleTpNullable, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 20 TpList <- <('[' ']' Tp)> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				if buffer[position] != rune('[') {
					goto l82
				}
				position++
				if buffer[position] != rune(']') {
					goto l82
				}
				position++
				if !_rules[ruleTp]() {
					goto l82
				}
				add(ruleTpList, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 21 TpName <- <([A-Z] ([a-z] / [A-Z] / [0-9])*?)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				if c := buffer[position]; c < rune('A') || c > rune('Z') {
					goto l84
				}
				position++
				{
					position86, tokenIndex86 := position, tokenIndex
				l88:
					{
						position89, tokenIndex89 := position, tokenIndex
						{
							position90, tokenIndex90 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l91
							}
							position++
							goto l90
						l91:
							position, tokenIndex = position90, tokenIndex90
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l92
							}
							position++
							goto l90
						l92:
							position, tokenIndex = position90, tokenIndex90
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l89
							}
							position++
						}
					l90:
						goto l88
					l89:
						position, tokenIndex = position89, tokenIndex89
					}
					goto l87

					position, tokenIndex = position86, tokenIndex86
				}
			l87:
				add(ruleTpName, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 22 WdLowCase <- <([a-z] ([a-z] / [A-Z] / [0-9])*?)> */
		func() bool {
			position93, tokenIndex93 := position, tokenIndex
			{
				position94 := position
				if c := buffer[position]; c < rune('a') || c > rune('z') {
					goto l93
				}
				position++
				{
					position95, tokenIndex95 := position, tokenIndex
				l97:
					{
						position98, tokenIndex98 := position, tokenIndex
						{
							position99, tokenIndex99 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l100
							}
							position++
							goto l99
						l100:
							position, tokenIndex = position99, tokenIndex99
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l101
							}
							position++
							goto l99
						l101:
							position, tokenIndex = position99, tokenIndex99
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l98
							}
							position++
						}
					l99:
						goto l97
					l98:
						position, tokenIndex = position98, tokenIndex98
					}
					goto l96

					position, tokenIndex = position95, tokenIndex95
				}
			l96:
				add(ruleWdLowCase, position94)
			}
			return true
		l93:
			position, tokenIndex = position93, tokenIndex93
			return false
		},
		/* 23 SpLn <- <(' ' / '\t')+> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position106, tokenIndex106 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l107
					}
					position++
					goto l106
				l107:
					position, tokenIndex = position106, tokenIndex106
					if buffer[position] != rune('\t') {
						goto l102
					}
					position++
				}
			l106:
			l104:
				{
					position105, tokenIndex105 := position, tokenIndex
					{
						position108, tokenIndex108 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l109
						}
						position++
						goto l108
					l109:
						position, tokenIndex = position108, tokenIndex108
						if buffer[position] != rune('\t') {
							goto l105
						}
						position++
					}
				l108:
					goto l104
				l105:
					position, tokenIndex = position105, tokenIndex105
				}
				add(ruleSpLn, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 24 SpOpt <- <(SpLn / '\n')*> */
		func() bool {
			{
				position111 := position
			l112:
				{
					position113, tokenIndex113 := position, tokenIndex
					{
						position114, tokenIndex114 := position, tokenIndex
						if !_rules[ruleSpLn]() {
							goto l115
						}
						goto l114
					l115:
						position, tokenIndex = position114, tokenIndex114
						if buffer[position] != rune('\n') {
							goto l113
						}
						position++
					}
				l114:
					goto l112
				l113:
					position, tokenIndex = position113, tokenIndex113
				}
				add(ruleSpOpt, position111)
			}
			return true
		},
		/* 25 SpLnOpt <- <(' ' / '\t')*> */
		func() bool {
			{
				position117 := position
			l118:
				{
					position119, tokenIndex119 := position, tokenIndex
					{
						position120, tokenIndex120 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l121
						}
						position++
						goto l120
					l121:
						position, tokenIndex = position120, tokenIndex120
						if buffer[position] != rune('\t') {
							goto l119
						}
						position++
					}
				l120:
					goto l118
				l119:
					position, tokenIndex = position119, tokenIndex119
				}
				add(ruleSpLnOpt, position117)
			}
			return true
		},
		/* 26 SpVr <- <'\n'+> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('\n') {
					goto l122
				}
				position++
			l124:
				{
					position125, tokenIndex125 := position, tokenIndex
					if buffer[position] != rune('\n') {
						goto l125
					}
					position++
					goto l124
				l125:
					position, tokenIndex = position125, tokenIndex125
				}
				add(ruleSpVr, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 27 OEQ <- <'='> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune('=') {
					goto l126
				}
				position++
				add(ruleOEQ, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 28 KSCM <- <('s' 'c' 'h' 'e' 'm' 'a')> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if buffer[position] != rune('s') {
					goto l128
				}
				position++
				if buffer[position] != rune('c') {
					goto l128
				}
				position++
				if buffer[position] != rune('h') {
					goto l128
				}
				position++
				if buffer[position] != rune('e') {
					goto l128
				}
				position++
				if buffer[position] != rune('m') {
					goto l128
				}
				position++
				if buffer[position] != rune('a') {
					goto l128
				}
				position++
				add(ruleKSCM, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 29 KEN <- <('e' 'n' 'u' 'm')> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if buffer[position] != rune('e') {
					goto l130
				}
				position++
				if buffer[position] != rune('n') {
					goto l130
				}
				position++
				if buffer[position] != rune('u') {
					goto l130
				}
				position++
				if buffer[position] != rune('m') {
					goto l130
				}
				position++
				add(ruleKEN, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 30 KST <- <('s' 't' 'r' 'u' 'c' 't')> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				if buffer[position] != rune('s') {
					goto l132
				}
				position++
				if buffer[position] != rune('t') {
					goto l132
				}
				position++
				if buffer[position] != rune('r') {
					goto l132
				}
				position++
				if buffer[position] != rune('u') {
					goto l132
				}
				position++
				if buffer[position] != rune('c') {
					goto l132
				}
				position++
				if buffer[position] != rune('t') {
					goto l132
				}
				position++
				add(ruleKST, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 31 KRV <- <('r' 'e' 's' 'o' 'l' 'v' 'e' 'r')> */
		func() bool {
			position134, tokenIndex134 := position, tokenIndex
			{
				position135 := position
				if buffer[position] != rune('r') {
					goto l134
				}
				position++
				if buffer[position] != rune('e') {
					goto l134
				}
				position++
				if buffer[position] != rune('s') {
					goto l134
				}
				position++
				if buffer[position] != rune('o') {
					goto l134
				}
				position++
				if buffer[position] != rune('l') {
					goto l134
				}
				position++
				if buffer[position] != rune('v') {
					goto l134
				}
				position++
				if buffer[position] != rune('e') {
					goto l134
				}
				position++
				if buffer[position] != rune('r') {
					goto l134
				}
				position++
				add(ruleKRV, position135)
			}
			return true
		l134:
			position, tokenIndex = position134, tokenIndex134
			return false
		},
		/* 32 KTR <- <('t' 'r' 'a' 'i' 't')> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if buffer[position] != rune('t') {
					goto l136
				}
				position++
				if buffer[position] != rune('r') {
					goto l136
				}
				position++
				if buffer[position] != rune('a') {
					goto l136
				}
				position++
				if buffer[position] != rune('i') {
					goto l136
				}
				position++
				if buffer[position] != rune('t') {
					goto l136
				}
				position++
				add(ruleKTR, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 33 KUN <- <('u' 'n' 'i' 'o' 'n')> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if buffer[position] != rune('u') {
					goto l138
				}
				position++
				if buffer[position] != rune('n') {
					goto l138
				}
				position++
				if buffer[position] != rune('i') {
					goto l138
				}
				position++
				if buffer[position] != rune('o') {
					goto l138
				}
				position++
				if buffer[position] != rune('n') {
					goto l138
				}
				position++
				add(ruleKUN, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 34 KQR <- <('q' 'u' 'e' 'r' 'y')> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != rune('q') {
					goto l140
				}
				position++
				if buffer[position] != rune('u') {
					goto l140
				}
				position++
				if buffer[position] != rune('e') {
					goto l140
				}
				position++
				if buffer[position] != rune('r') {
					goto l140
				}
				position++
				if buffer[position] != rune('y') {
					goto l140
				}
				position++
				add(ruleKQR, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 35 KMT <- <('m' 'u' 't' 'a' 't' 'i' 'o' 'n')> */
		func() bool {
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				if buffer[position] != rune('m') {
					goto l142
				}
				position++
				if buffer[position] != rune('u') {
					goto l142
				}
				position++
				if buffer[position] != rune('t') {
					goto l142
				}
				position++
				if buffer[position] != rune('a') {
					goto l142
				}
				position++
				if buffer[position] != rune('t') {
					goto l142
				}
				position++
				if buffer[position] != rune('i') {
					goto l142
				}
				position++
				if buffer[position] != rune('o') {
					goto l142
				}
				position++
				if buffer[position] != rune('n') {
					goto l142
				}
				position++
				add(ruleKMT, position143)
			}
			return true
		l142:
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 36 KSB <- <('s' 'u' 'b' 's' 'c' 'r' 'i' 'p' 't' 'i' 'o' 'n')> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if buffer[position] != rune('s') {
					goto l144
				}
				position++
				if buffer[position] != rune('u') {
					goto l144
				}
				position++
				if buffer[position] != rune('b') {
					goto l144
				}
				position++
				if buffer[position] != rune('s') {
					goto l144
				}
				position++
				if buffer[position] != rune('c') {
					goto l144
				}
				position++
				if buffer[position] != rune('r') {
					goto l144
				}
				position++
				if buffer[position] != rune('i') {
					goto l144
				}
				position++
				if buffer[position] != rune('p') {
					goto l144
				}
				position++
				if buffer[position] != rune('t') {
					goto l144
				}
				position++
				if buffer[position] != rune('i') {
					goto l144
				}
				position++
				if buffer[position] != rune('o') {
					goto l144
				}
				position++
				if buffer[position] != rune('n') {
					goto l144
				}
				position++
				add(ruleKSB, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 37 PRN <- <'('> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if buffer[position] != rune('(') {
					goto l146
				}
				position++
				add(rulePRN, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 38 PRNE <- <')'> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				if buffer[position] != rune(')') {
					goto l148
				}
				position++
				add(rulePRNE, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 39 BLK <- <'{'> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if buffer[position] != rune('{') {
					goto l150
				}
				position++
				add(ruleBLK, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 40 BLKE <- <'}'> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				if buffer[position] != rune('}') {
					goto l152
				}
				position++
				add(ruleBLKE, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
	}
	p.rules = _rules
	return nil
}
